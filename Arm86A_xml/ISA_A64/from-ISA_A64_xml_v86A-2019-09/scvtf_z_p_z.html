<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>SCVTF</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">SCVTF</h2><p id="desc">Signed integer convert to floating-point (predicated).
          <p></p><p><p class="aml">Convert to floating-point from the signed integer in each active element of the source vector, and place the results in the corresponding elements of the destination vector. Inactive elements in the destination vector register remain unmodified.</p><p class="aml">If the input and result types have a different size the smaller type is held unpacked in the least significant bits of elements of the larger size. When the input is the smaller type the upper bits of each source element are ignored. When the result is the smaller type the results are zero-extended to fill each destination element.</p></p></p><p class="desc">
      It has encodings from 7 classes:
      <a href="#scvtf_z_p_z_h2fp16">16-bit to half-precision</a>
      , 
      <a href="#scvtf_z_p_z_w2fp16">32-bit to half-precision</a>
      , 
      <a href="#scvtf_z_p_z_w2s">32-bit to single-precision</a>
      , 
      <a href="#scvtf_z_p_z_w2d">32-bit to double-precision</a>
      , 
      <a href="#scvtf_z_p_z_x2fp16">64-bit to half-precision</a>
      , 
      <a href="#scvtf_z_p_z_x2s">64-bit to single-precision</a>
       and 
      <a href="#scvtf_z_p_z_x2d">64-bit to double-precision</a></p><h3 class="classheading"><a id="scvtf_z_p_z_h2fp16" name="scvtf_z_p_z_h2fp16"></a>16-bit to half-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">16-bit to half-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_h2fp16" name="scvtf_z_p_z_h2fp16"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.H, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.H</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 16;
integer d_esize = 16;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_w2fp16" name="scvtf_z_p_z_w2fp16"></a>32-bit to half-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit to half-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_w2fp16" name="scvtf_z_p_z_w2fp16"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.H, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.S</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 32;
integer d_esize = 16;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_w2s" name="scvtf_z_p_z_w2s"></a>32-bit to single-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit to single-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_w2s" name="scvtf_z_p_z_w2s"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.S, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.S</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 32;
integer d_esize = 32;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_w2d" name="scvtf_z_p_z_w2d"></a>32-bit to double-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit to double-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_w2d" name="scvtf_z_p_z_w2d"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.D, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.S</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 32;
integer d_esize = 64;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_x2fp16" name="scvtf_z_p_z_x2fp16"></a>64-bit to half-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">1</td><td class="lr">1</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit to half-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_x2fp16" name="scvtf_z_p_z_x2fp16"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.H, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.D</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 64;
integer d_esize = 16;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_x2s" name="scvtf_z_p_z_x2s"></a>64-bit to single-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit to single-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_x2s" name="scvtf_z_p_z_x2s"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.S, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.D</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 64;
integer d_esize = 32;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><h3 class="classheading"><a id="scvtf_z_p_z_x2d" name="scvtf_z_p_z_x2d"></a>64-bit to double-precision</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">1</td><td class="lr">1</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Zn</td><td class="lr" colspan="5">Zd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit to double-precision</h4><p class="asm-code"><a id="scvtf_z_p_z_x2d" name="scvtf_z_p_z_x2d"></a>SCVTF   <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd></a>.D, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/M, <a href="#zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn></a>.D</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer s_esize = 64;
integer d_esize = 64;
boolean unsigned = FALSE;
<a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(FPCR);</p><p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zd></td><td><a id="zd" name="zd"></a><p class="aml">Is the name of the destination scalable vector register, encoded in the "Zd" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Pg></td><td><a id="pg" name="pg"></a><p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn></td><td><a id="zn" name="zn"></a><p class="aml">Is the name of the source scalable vector register, encoded in the "Zn" field.</p></td></tr></table></div><p class="syntax-notes"></p><div class="ps" psname="commonps"><a id="commonps" name="commonps"></a><h3 class="pseudocode">Operation</h3><p class="pseudocode">CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) fpval = <a href="shared_pseudocode.html#impl-shared.FixedToFP.5" title="function: bits(N) FixedToFP(bits(M) op, integer fbits, boolean unsigned, FPCRType fpcr, FPRounding rounding)">FixedToFP</a>(element&lt;s_esize-1:0>, 0, unsigned, FPCR, rounding);
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(fpval);

Z[d] = result;</p></div><h3>Operational information</h3><p class="aml">
          This instruction might be immediately preceded in program order by a <span class="asm-code">MOVPRFX</span> <ins>instruction.</ins><del>instruction</del> <ins>The</ins><del>that conforms to all of the following requirements, otherwise the behavior of either or both instructions is</del> <span class="asm-code"><ins>MOVPRFX</ins><del>unpredictable</del></span> <ins>instruction must conform to all of the following requirements, otherwise the behavior of the</ins><del>:</del> <ul><li><del>The </del><span class="asm-code"><del>MOVPRFX</del></span><del> instruction must specify the same destination register as this instruction.</del></li><li><del>The destination register must not refer to architectural register state referenced by any other source operand register of this instruction.</del></li></ul><del>
          The </del><span class="asm-code">MOVPRFX</span><ins> and this instruction is </ins><span class="arm-defined-word"><ins>unpredictable</ins></span><del>instructions that can be used with this instruction are as follows</del>:
        </p><ul><li><ins>The</ins><del>An unpredicated</del> <span class="asm-code">MOVPRFX</span> <ins>instruction must be unpredicated, or be predicated using the same governing predicate register and source element size as this </ins>instruction.</li><li><ins>The</ins><del>A predicated</del> <span class="asm-code">MOVPRFX</span> instruction <ins>must</ins><del>using</del> <ins>specify </ins>the same <ins>destination</ins><del>governing</del> <del>predicate </del>register<del> and source element size</del> as this instruction.</li><li><ins>The destination register must not refer to architectural register state referenced by any other source operand register of this instruction.</ins></li></ul><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v31.05b</ins><del>v31.04</del>, AdvSIMD v29.02, pseudocode <ins>v2019-12_rc3_1</ins><del>v2019-09_rc2_1</del>, sve <ins>v2019-12_rc3</ins><del>v2019-09_rc3</del>
      ; Build timestamp: <ins>2019-12-13T14</ins><del>2019-09-27T17</del>:<ins>50</ins><del>32</del>
    </p><p class="copyconf">
      Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>