<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>LD4H (scalar plus immediate)</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">LD4H (scalar plus immediate)</h2><p id="desc">Contiguous load four-halfword structures to four vectors (immediate index).
          <p></p><p><p class="aml">Contiguous load four-halfword structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and an immediate index which is a multiple of 4 in the range -32 to 28 that is multiplied by the vector's in-memory size, irrespective of predication, </p><p class="aml">Each predicate element applies to the same element number in each of the four vector registers, or equivalently to the four consecutive halfwords in memory which make up each structure. Inactive elements will not read Device memory or signal a fault, and the corresponding element is set to zero in each of the four destination vector registers.</p></p></p><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="l">1</td><td class="r">1</td><td class="lr">0</td><td class="lr" colspan="4">imm4</td><td class="l">1</td><td>1</td><td class="r">1</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">SVE</h4><p class="asm-code"><a id="ld4h_z_p_bi_contiguous" name="ld4h_z_p_bi_contiguous"></a>LD4H    { <a href="#zt1" title="First scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt1></a>.H, <a href="#zt2" title="Second scalable vector register to be transferred (field Zt)">&lt;Zt2></a>.H, <a href="#zt3" title="Third scalable vector register to be transferred (field Zt)">&lt;Zt3></a>.H, <a href="#zt4" title="Fourth scalable vector register to be transferred (field Zt)">&lt;Zt4></a>.H }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>{, #<a href="#imm" title="Optional signed immediate vector offset, multiple of 4 [-32-28], default 0 (field &quot;imm4&quot;)">&lt;imm></a>, MUL VL}]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 16;
integer offset = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(imm4);
integer nreg = 4;</p><p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt1></td><td><a id="zt1" name="zt1"></a><p class="aml">Is the name of the first scalable vector register to be transferred, encoded in the "Zt" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt2></td><td><a id="zt2" name="zt2"></a><p class="aml">Is the name of the second scalable vector register to be transferred, encoded as "Zt" plus 1 modulo 32.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt3></td><td><a id="zt3" name="zt3"></a><p class="aml">Is the name of the third scalable vector register to be transferred, encoded as "Zt" plus 2 modulo 32.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt4></td><td><a id="zt4" name="zt4"></a><p class="aml">Is the name of the fourth scalable vector register to be transferred, encoded as "Zt" plus 3 modulo 32.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Pg></td><td><a id="pg" name="pg"></a><p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn|SP></td><td><a id="xn_sp" name="xn_sp"></a><p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;imm></td><td><a id="imm" name="imm"></a><p class="aml">Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the "imm4" field.</p></td></tr></table></div><p class="syntax-notes"></p><div class="ps" psname="commonps"><a id="commonps" name="commonps"></a><h3 class="pseudocode">Operation</h3><p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()"><del>CheckSVEEnabled</del></a><ins>CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then</ins><del>();
integer elements =</del>
    <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL"><del>VL</del></a><del> DIV esize;
bits(64) base;
bits(64) addr;
bits(</del><a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL"><del>PL</del></a><del>) mask = </del><a href="shared_pseudocode.html#impl-aarch64.P.read.1" title="accessor: bits(width) P[integer n]"><del>P</del></a><del>[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(</del><a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL"><del>VL</del></a><del>) values;

if n == 31 then
    </del><a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a><ins>() then</ins><del>() then SetNotTagCheckedInstruction(TRUE);
    base =</del> <a href="shared_pseudocode.html#impl-aarch64.SetTagCheckedInstruction.1" title="function: SetTagCheckedInstruction(boolean checked)"><ins>SetTagCheckedInstruction</ins></a><ins>(FALSE);
    base = </ins><a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
else
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a><ins>() then</ins><del>() then SetNotTagCheckedInstruction(FALSE);
    base =</del> <a href="shared_pseudocode.html#impl-aarch64.SetTagCheckedInstruction.1" title="function: SetTagCheckedInstruction(boolean checked)"><ins>SetTagCheckedInstruction</ins></a><ins>(TRUE);
    base = </ins><a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
<ins>        if ElemP[mask, e, esize] == '1' then</ins><del>        if</del>
            <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><del>[mask, e, esize] == '1' then
            </del><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[values[r], e, esize] = <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</a>[addr, mbytes, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>];
        else
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[values[r], e, esize] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a><del>();
        addr = addr + mbytes;

for r = 0 to nreg-1
    </del><a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value"><del>Z</del></a><ins>();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];</ins><del>[(t+r) MOD 32] = values[r];</del></p></div><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v31.05b</ins><del>v31.04</del>, AdvSIMD v29.02, pseudocode <ins>v2019-12_rc3_1</ins><del>v2019-09_rc2_1</del>, sve <ins>v2019-12_rc3</ins><del>v2019-09_rc3</del>
      ; Build timestamp: <ins>2019-12-13T14</ins><del>2019-09-27T17</del>:<ins>50</ins><del>32</del>
    </p><p class="copyconf">
      Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>