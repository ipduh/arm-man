<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>LD1H (scalar plus vector)</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">LD1H (scalar plus vector)</h2><p id="desc">Gather load unsigned halfwords to vector (vector index).
          <p></p><p><p class="aml">Gather load of unsigned halfwords to active elements of a vector register from memory addresses generated by a 64-bit scalar base plus vector index. The index values are optionally first sign or zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive elements will not read Device memory or signal faults, and are set to zero in the destination vector.</p></p></p><p class="desc">
      It has encodings from 6 classes:
      <a href="#ld1h_z_p_bz_s_x32_scaled">32-bit scaled offset</a>
      , 
      <a href="#ld1h_z_p_bz_d_x32_scaled">32-bit unpacked scaled offset</a>
      , 
      <a href="#ld1h_z_p_bz_d_x32_unscaled">32-bit unpacked unscaled offset</a>
      , 
      <a href="#ld1h_z_p_bz_s_x32_unscaled">32-bit unscaled offset</a>
      , 
      <a href="#ld1h_z_p_bz_d_64_scaled">64-bit scaled offset</a>
       and 
      <a href="#ld1h_z_p_bz_d_64_unscaled">64-bit unscaled offset</a></p><h3 class="classheading"><a id="ld1h_z_p_bz_s_x32_scaled" name="ld1h_z_p_bz_s_x32_scaled"></a>32-bit scaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">xs</td><td class="lr">1</td><td class="lr" colspan="5">Zm</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit scaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_s_x32_scaled" name="ld1h_z_p_bz_s_x32_scaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.S }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.S, <a href="#mod" title="Index extend and shift specifier (field &quot;xs&quot;) [SXTW,UXTW]">&lt;mod></a> #1]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;</p><h3 class="classheading"><a id="ld1h_z_p_bz_d_x32_scaled" name="ld1h_z_p_bz_d_x32_scaled"></a>32-bit unpacked scaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="lr">xs</td><td class="lr">1</td><td class="lr" colspan="5">Zm</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit unpacked scaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_d_x32_scaled" name="ld1h_z_p_bz_d_x32_scaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.D }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.D, <a href="#mod" title="Index extend and shift specifier (field &quot;xs&quot;) [SXTW,UXTW]">&lt;mod></a> #1]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;</p><h3 class="classheading"><a id="ld1h_z_p_bz_d_x32_unscaled" name="ld1h_z_p_bz_d_x32_unscaled"></a>32-bit unpacked unscaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="lr">xs</td><td class="lr">0</td><td class="lr" colspan="5">Zm</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit unpacked unscaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_d_x32_unscaled" name="ld1h_z_p_bz_d_x32_unscaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.D }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.D, <a href="#mod" title="Index extend and shift specifier (field &quot;xs&quot;) [SXTW,UXTW]">&lt;mod></a>]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;</p><h3 class="classheading"><a id="ld1h_z_p_bz_s_x32_unscaled" name="ld1h_z_p_bz_s_x32_unscaled"></a>32-bit unscaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="lr">xs</td><td class="lr">0</td><td class="lr" colspan="5">Zm</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit unscaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_s_x32_unscaled" name="ld1h_z_p_bz_s_x32_unscaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.S }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.S, <a href="#mod" title="Index extend and shift specifier (field &quot;xs&quot;) [SXTW,UXTW]">&lt;mod></a>]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;</p><h3 class="classheading"><a id="ld1h_z_p_bz_d_64_scaled" name="ld1h_z_p_bz_d_64_scaled"></a>64-bit scaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="5">Zm</td><td class="lr">1</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit scaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_d_64_scaled" name="ld1h_z_p_bz_d_64_scaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.D }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.D, LSL #1]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 1;</p><h3 class="classheading"><a id="ld1h_z_p_bz_d_64_unscaled" name="ld1h_z_p_bz_d_64_unscaled"></a>64-bit unscaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="lr" colspan="5">Zm</td><td class="lr">1</td><td class="lr">1</td><td class="lr">0</td><td class="lr" colspan="3">Pg</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit unscaled offset</h4><p class="asm-code"><a id="ld1h_z_p_bz_d_64_unscaled" name="ld1h_z_p_bz_d_64_unscaled"></a>LD1H    { <a href="#zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt></a>.D }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg></a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>, <a href="#zm" title="Offset scalable vector register (field &quot;Zm&quot;)">&lt;Zm></a>.D]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;</p><p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt></td><td><a id="zt" name="zt"></a><p class="aml">Is the name of the scalable vector register to be transferred, encoded in the "Zt" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Pg></td><td><a id="pg" name="pg"></a><p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn|SP></td><td><a id="xn_sp" name="xn_sp"></a><p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zm></td><td><a id="zm" name="zm"></a><p class="aml">Is the name of the offset scalable vector register, encoded in the "Zm" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;mod></td><td><a id="mod" name="mod"></a>
        Is the index extend and shift specifier, 
    encoded in 
    <q>xs</q>:
      
        <table class="valuetable"><thead><tr><th class="bitfield">xs</th><th class="symbol">&lt;mod></th></tr></thead><tbody><tr><td class="bitfield">0</td><td class="symbol">UXTW</td></tr><tr><td class="bitfield">1</td><td class="symbol">SXTW</td></tr></tbody></table></td></tr></table></div><p class="syntax-notes"></p><div class="ps" psname="commonps"><a id="commonps" name="commonps"></a><h3 class="pseudocode">Operation</h3><p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()"><del>CheckSVEEnabled</del></a><ins>CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if</ins><del>();
integer elements =</del> <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL"><del>VL</del></a><del> DIV esize;
bits(64) base;
bits(64) addr;
bits(</del><a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL"><del>VL</del></a><del>) offset = </del><a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]"><del>Z</del></a><del>[m];
bits(</del><a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL"><del>PL</del></a><del>) mask = </del><a href="shared_pseudocode.html#impl-aarch64.P.read.1" title="accessor: bits(width) P[integer n]"><del>P</del></a><del>[g];
bits(</del><a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL"><del>VL</del></a><del>) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a><ins>() then</ins><del>() then SetNotTagCheckedInstruction(FALSE);

if n == 31 then</del> <a href="shared_pseudocode.html#impl-aarch64.SetTagCheckedInstruction.1" title="function: SetTagCheckedInstruction(boolean checked)"><ins>SetTagCheckedInstruction</ins></a><ins>(TRUE);

if n == 31 then
    </ins><a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    base = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
else
    base = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

for e = 0 to elements-1
<ins>    if ElemP[mask, e, esize] == '1' then
        integer off =</ins><del>    if</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><del>[mask, e, esize] == '1' then
        integer off = </del><a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[offset, e, esize]&lt;offs_size-1:0>, offs_unsigned);
        addr = base + (off &lt;&lt; scale);
        data = <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</a>[addr, mbytes, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(data, esize, unsigned);
    else
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a><del>();

</del><a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value"><del>Z</del></a><ins>();

Z[t] = result;</ins><del>[t] = result;</del></p></div><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v31.05b</ins><del>v31.04</del>, AdvSIMD v29.02, pseudocode <ins>v2019-12_rc3_1</ins><del>v2019-09_rc2_1</del>, sve <ins>v2019-12_rc3</ins><del>v2019-09_rc3</del>
      ; Build timestamp: <ins>2019-12-13T14</ins><del>2019-09-27T17</del>:<ins>50</ins><del>32</del>
    </p><p class="copyconf">
      Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>