<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" encoding="UTF-8" href="iform.xsl" version="1.0"?>
<!DOCTYPE instructionsection PUBLIC "-//ARM//DTD instructionsection //EN" "iform-p.dtd">
<!-- Copyright (c) 2010-2019 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->

<instructionsection id="fmmla_z_zzz" title="FMMLA" type="instruction">
  <docvars>
    <docvar key="instr-class" value="sve" />
    <docvar key="isa" value="A64" />
    <docvar key="mnemonic" value="FMMLA" />
  </docvars>
  <heading>FMMLA</heading>
  <desc>
    <brief>Floating-point matrix multiply-accumulate</brief>
    <description>
      <para>The floating-point matrix multiply-accumulate instruction supports single-precision and double-precision data types in a 2×2 matrix contained in segments of 128 or 256 bits, respectively. It multiplies the 2×2 matrix in each segment of the first source vector by the 2×2 matrix in the corresponding segment of the second source vector. The resulting 2×2 matrix product is then destructively added to the matrix accumulator held in the corresponding segment of the addend and destination vector. This is equivalent to performing a 2-way dot product per destination element. This instruction is unpredicated. The single-precision variant is vector length agnostic. The double-precision variant requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.</para>
      <para>ID_AA64ZFR0_EL1.F32MM indicates whether the single-precision variant is implemented.</para>
      <para>ID_AA64ZFR0_EL1.F64MM indicates whether the double-precision variant is implemented.</para>
    </description>
    <status>Green</status>
    <predicated>False</predicated>
    <takes_movprfx>True</takes_movprfx>
    <takes_pred_movprfx>False</takes_pred_movprfx>
  </desc>
  <alias_list howmany="0"></alias_list>
  <classes>
    <classesintro count="2">
      <txt>It has encodings from 2 classes:</txt>
      <a href="#fmmla_z_zzz_s">32-bit element</a>
      <txt> and </txt>
      <a href="#fmmla_z_zzz_d">64-bit element</a>
    </classesintro>
    <iclass name="32-bit element" oneof="2" id="fmmla_z_zzz_s" no_encodings="1" isa="A64">
      <docvars>
        <docvar key="instr-class" value="sve" />
        <docvar key="isa" value="A64" />
        <docvar key="mnemonic" value="FMMLA" />
        <docvar key="sve-elem-type" value="32-elem" />
      </docvars>
      <iclassintro count="1"></iclassintro>
      <regdiagram form="32" psname="FMMLA-Z.ZZZ-S">
        <box hibit="31" width="8" settings="8">
          <c>0</c>
          <c>1</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
        </box>
        <box hibit="23" name="opc&lt;1&gt;" settings="1">
          <c>1</c>
        </box>
        <box hibit="22" name="opc&lt;0&gt;" settings="1">
          <c>0</c>
        </box>
        <box hibit="21" settings="1">
          <c>1</c>
        </box>
        <box hibit="20" width="5" name="Zm" usename="1">
          <c colspan="5"></c>
        </box>
        <box hibit="15" width="6" settings="6">
          <c>1</c>
          <c>1</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
          <c>1</c>
        </box>
        <box hibit="9" width="5" name="Zn" usename="1">
          <c colspan="5"></c>
        </box>
        <box hibit="4" width="5" name="Zda" usename="1">
          <c colspan="5"></c>
        </box>
      </regdiagram>
      <encoding name="fmmla_z_zzz_s" oneofinclass="1" oneof="2" label="32-bit element">
        <docvars>
          <docvar key="instr-class" value="sve" />
          <docvar key="isa" value="A64" />
          <docvar key="mnemonic" value="FMMLA" />
          <docvar key="sve-elem-type" value="32-elem" />
        </docvars>
        <asmtemplate><text>FMMLA   </text><a link="zda" hover="Third source and destination scalable vector register (field &quot;Zda&quot;)">&lt;Zda&gt;</a><text>.S, </text><a link="zn" hover="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a><text>.S, </text><a link="zm" hover="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a><text>.S</text></asmtemplate>
      </encoding>
      <ps_section howmany="1">
        <ps name="FMMLA-Z.ZZZ-S" mylink="FMMLA-Z.ZZZ-S" enclabels="" sections="1" secttype="noheading">
          <pstext mayhavelinks="1" section="Decode" rep_section="decode">if !HaveSVEFP32MatMulExt() then UNDEFINED;
integer esize = 32;
integer n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer da = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zda);</pstext>
        </ps>
      </ps_section>
    </iclass>
    <iclass name="64-bit element" oneof="2" id="fmmla_z_zzz_d" no_encodings="1" isa="A64">
      <docvars>
        <docvar key="instr-class" value="sve" />
        <docvar key="isa" value="A64" />
        <docvar key="mnemonic" value="FMMLA" />
        <docvar key="sve-elem-type" value="64-elem" />
      </docvars>
      <iclassintro count="1"></iclassintro>
      <regdiagram form="32" psname="FMMLA-Z.ZZZ-D">
        <box hibit="31" width="8" settings="8">
          <c>0</c>
          <c>1</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
        </box>
        <box hibit="23" name="opc&lt;1&gt;" settings="1">
          <c>1</c>
        </box>
        <box hibit="22" name="opc&lt;0&gt;" settings="1">
          <c>1</c>
        </box>
        <box hibit="21" settings="1">
          <c>1</c>
        </box>
        <box hibit="20" width="5" name="Zm" usename="1">
          <c colspan="5"></c>
        </box>
        <box hibit="15" width="6" settings="6">
          <c>1</c>
          <c>1</c>
          <c>1</c>
          <c>0</c>
          <c>0</c>
          <c>1</c>
        </box>
        <box hibit="9" width="5" name="Zn" usename="1">
          <c colspan="5"></c>
        </box>
        <box hibit="4" width="5" name="Zda" usename="1">
          <c colspan="5"></c>
        </box>
      </regdiagram>
      <encoding name="fmmla_z_zzz_d" oneofinclass="1" oneof="2" label="64-bit element">
        <docvars>
          <docvar key="instr-class" value="sve" />
          <docvar key="isa" value="A64" />
          <docvar key="mnemonic" value="FMMLA" />
          <docvar key="sve-elem-type" value="64-elem" />
        </docvars>
        <asmtemplate><text>FMMLA   </text><a link="zda" hover="Third source and destination scalable vector register (field &quot;Zda&quot;)">&lt;Zda&gt;</a><text>.D, </text><a link="zn" hover="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a><text>.D, </text><a link="zm" hover="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a><text>.D</text></asmtemplate>
      </encoding>
      <ps_section howmany="1">
        <ps name="FMMLA-Z.ZZZ-D" mylink="FMMLA-Z.ZZZ-D" enclabels="" sections="1" secttype="noheading">
          <pstext mayhavelinks="1" section="Decode" rep_section="decode">if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 64;
integer n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer da = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Zda);</pstext>
        </ps>
      </ps_section>
    </iclass>
  </classes>
  <explanations scope="all">
    <explanation enclist="fmmla_z_zzz_s, fmmla_z_zzz_d" symboldefcount="1">
      <symbol link="zda">&lt;Zda&gt;</symbol>
      <account encodedin="Zda">
        <intro>
          <para>Is the name of the third source and destination scalable vector register, encoded in the "Zda" field.</para>
        </intro>
      </account>
    </explanation>
    <explanation enclist="fmmla_z_zzz_s, fmmla_z_zzz_d" symboldefcount="1">
      <symbol link="zn">&lt;Zn&gt;</symbol>
      <account encodedin="Zn">
        <intro>
          <para>Is the name of the first source scalable vector register, encoded in the "Zn" field.</para>
        </intro>
      </account>
    </explanation>
    <explanation enclist="fmmla_z_zzz_s, fmmla_z_zzz_d" symboldefcount="1">
      <symbol link="zm">&lt;Zm&gt;</symbol>
      <account encodedin="Zm">
        <intro>
          <para>Is the name of the second source scalable vector register, encoded in the "Zm" field.</para>
        </intro>
      </account>
    </explanation>
  </explanations>
  <ps_section howmany="1">
    <ps name="FMMLA-Z.ZZZ-S" mylink="commonps" enclabels="" sections="1" secttype="Operation">
      <pstext mayhavelinks="1" section="Execute" rep_section="execute">CheckSVEEnabled();
if VL &lt; esize * 4 then UNDEFINED;
integer segments = VL DIV (4 * esize);
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
bits(4*esize) op1, op2;
bits(4*esize) res, addend;

for s = 0 to segments-1
    op1    = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1, s, 4*esize];
    op2    = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, s, 4*esize];
    addend = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand3, s, 4*esize];
    res    = FPMatMulAdd(addend, op1, op2, esize, FPCR);
    <a link="impl-shared.Elem.write.3" file="shared_pseudocode.xml" hover="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, s, 4*esize] = res;

Z[da] = result;</pstext>
    </ps>
  </ps_section>
</instructionsection>
