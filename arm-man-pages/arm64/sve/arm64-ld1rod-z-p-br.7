.nh
.TH "LD1ROD (scalar plus scalar)" "7" " "  "instruction" "sve"
.SS LD1ROD (scalar plus scalar)
 Contiguous load and replicate four doublewords (scalar index)

 Load four contiguous doublewords to elements of a 256-bit (octaword) vector
 from the memory address generated by a 64-bit scalar base address and scalar
 index which is multiplied by 8 and added to the base address.

 Inactive elements will not read Device memory or signal a fault, and are set to
 zero.

 The resulting 256-bit vector is then replicated to fill the destination vector.
 The instruction requires that the current vector length is at least 256 bits,
 and if the current vector length is not an integer multiple of 256 bits then
 the trailing bits in the destination vector are set to zero.

 Only the first four predicate elements are used and higher numbered predicate
 elements are ignored.

 ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

 Status : Amber

 Predicated : True



.SS SVE - A64 - ld1rod_z_p_br_contiguous
 
                                                                   
                   23                                              
                 24 |                                              
               25 | |  21        16    13    10         5         0
                | | |   |         |     |     |         |         |
   1 0 1 0 0 1 0|1|1|0 1|. . . . .|0 0 0|. . .|. . . . .|. . . . .|
                | | |   |               |     |         |
                | | |   `-Rm            `-Pg  `-Rn      `-Zt
                | | `-ssz
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
 
 if !HaveSVEFP64MatMulExt() then UNDEFINED;
 if Rm == '11111' then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 integer g = UInt(Pg);
 integer esize = 64;
 
 CheckSVEEnabled();
 if VL < 256 then UNDEFINED;
 integer elements = 256 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low bits only
 bits(64) offset;
 bits(256) result;
 constant integer mbytes = esize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 offset = X[m];
 
 addr = base + UInt(offset) * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Xm>
  Encoded in Rm
  Is the 64-bit name of the general-purpose offset register, encoded in the "Rm"
  field.



.SS Operation

 CheckSVEEnabled();
 if VL < 256 then UNDEFINED;
 integer elements = 256 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low bits only
 bits(64) offset;
 bits(256) result;
 constant integer mbytes = esize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 offset = X[m];
 
 addr = base + UInt(offset) * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);

