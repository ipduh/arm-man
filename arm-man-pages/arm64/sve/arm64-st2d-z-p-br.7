.nh
.TH "ST2D (scalar plus scalar)" "7" " "  "instruction" "sve"
.SS ST2D (scalar plus scalar)
 Contiguous store two-doubleword structures from two vectors (scalar index)

 Contiguous store two-doubleword structures, each from the same element number
 in two vector registers to the memory address generated by a 64-bit scalar base
 and a 64-bit scalar index register scaled by the element size (LSL option) and
 added to the base address. After each structure access the index value is
 incremented by two. The index register is not updated by the instruction.

 Each predicate element applies to the same element number in each of the two
 vector registers, or equivalently to the two consecutive doublewords in memory
 which make up each structure. Inactive structures are not written to memory.

 Status : Green

 Predicated : True



.SS SVE - A64 - st2d_z_p_br_contiguous
 
                                                                   
                   23                                              
                 24 |                                              
               25 | |  21        16    13    10         5         0
                | | |   |         |     |     |         |         |
   1 1 1 0 0 1 0|1|1|0 1|. . . . .|0 1 1|. . .|. . . . .|. . . . .|
                | | |   |               |     |         |
                | | |   `-Rm            `-Pg  `-Rn      `-Zt
                | | `-opc
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
 
 if !HaveSVE() then UNDEFINED;
 if Rm == '11111' then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer nreg = 2;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(64) offset = X[m];
 constant integer mbytes = esize DIV 8;
 array [0..1] of bits(VL) values;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for r = 0 to nreg-1
     values[r] = Z[(t+r) MOD 32];
 
 for e = 0 to elements-1
     addr = base + UInt(offset) * mbytes;
     for r = 0 to nreg-1
         if ElemP[mask, e, esize] == '1' then
             Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
         addr = addr + mbytes;
     offset = offset + nreg;
 

.SS Assembler Symbols

 <Zt1>
  Encoded in Zt
  Is the name of the first scalable vector register to be transferred, encoded
  in the "Zt" field.

 <Zt2>
  Encoded in Zt
  Is the name of the second scalable vector register to be transferred, encoded
  as "Zt" plus 1 modulo 32.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Xm>
  Encoded in Rm
  Is the 64-bit name of the general-purpose offset register, encoded in the "Rm"
  field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(64) offset = X[m];
 constant integer mbytes = esize DIV 8;
 array [0..1] of bits(VL) values;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for r = 0 to nreg-1
     values[r] = Z[(t+r) MOD 32];
 
 for e = 0 to elements-1
     addr = base + UInt(offset) * mbytes;
     for r = 0 to nreg-1
         if ElemP[mask, e, esize] == '1' then
             Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
         addr = addr + mbytes;
     offset = offset + nreg;

