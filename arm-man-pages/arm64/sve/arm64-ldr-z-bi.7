.nh
.TH "LDR (vector)" "7" " "  "instruction" "sve"
.SS LDR (vector)
 Load vector register

 Load a vector register from a memory address generated by a 64-bit scalar base,
 plus an immediate offset in the range -256 to 255 which is multiplied by the
 current vector register size in bytes. This instruction is unpredicated.

 The load is performed as a stream of byte elements in ascending element order,
 without any endian conversion.

 Status : Green



.SS SVE - A64 - ldr_z_bi_
 
                                                                   
                                                                   
                                                                   
                     22          16    13    10         5         0
                      |           |     |     |         |         |
   1 0 0 0 0 1 0 1 1 0|. . . . . .|0 1 0|. . .|. . . . .|. . . . .|
                      |                 |     |         |
                      `-imm9h           |     `-Rn      `-Zt
                                        `-imm9l
  
  
 
.SS SVE
 
 LDR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer imm = SInt(imm9h:imm9l);
 
 CheckSVEEnabled();
 integer elements = VL DIV 8;
 bits(64) base;
 integer offset = imm * elements;
 bits(VL) result;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, FALSE);
 for e = 0 to elements-1
     Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
     offset = offset + 1;
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm9h:imm9l
  Is the optional signed immediate vector offset, in the range -256 to 255,
  defaulting to 0, encoded in the "imm9h:imm9l" fields.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV 8;
 bits(64) base;
 integer offset = imm * elements;
 bits(VL) result;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, FALSE);
 for e = 0 to elements-1
     Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
     offset = offset + 1;
 
 Z[t] = result;

