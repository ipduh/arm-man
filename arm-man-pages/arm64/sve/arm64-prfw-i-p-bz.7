.nh
.TH "PRFW (scalar plus vector)" "7" " "  "instruction" "sve"
.SS PRFW (scalar plus vector)
 Gather prefetch words (scalar plus vector)

 Gather prefetch of words from the active memory addresses generated by a 64-bit
 scalar base plus vector index. The index values are optionally first sign or
 zero-extended from 32 to 64 bits and then multiplied by 4. Inactive addresses
 are not prefetched from memory.

 The <prfop> symbol specifies the prefetch hint as a combination of three
 options: access type PLD for load or PST for store; target cache level L1, L2
 or L3; temporality (KEEP for temporal or STRM for non-temporal).

 Status : Green

 Predicated : True


It has encodings from 3 classes: 32-bit scaled offset, 32-bit unpacked scaled offset and 64-bit scaled offset

.SS 32-bit scaled offset - A64 - prfw_i_p_bz_s_x32_scaled
 
                                       13                          
                       21            14 |                          
                     22 |          15 | |                          
                   23 | |        16 | | |    10         5 4       0
                    | | |         | | | |     |         | |       |
   1 0 0 0 0 1 0 0 0|.|1|. . . . .|0|1|0|. . .|. . . . .|0|. . . .|
                    |   |           | | |     |           |
                    |   `-Zm        | | `-Pg  `-Rn        `-prfop
                    `-xs            | `-msz<0>
                                    `-msz<1>
  
  
 
.SS 32-bit scaled offset
 
 PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 32;
 integer g = UInt(Pg);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer level = UInt(prfop<2:1>);
 boolean stream = (prfop<0> == '1');
 pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
 integer offs_size = 32;
 boolean offs_unsigned = (xs == '0');
 integer scale = 2;
.SS 32-bit unpacked scaled offset - A64 - prfw_i_p_bz_d_x32_scaled
 
                                       13                          
                       21            14 |                          
                     22 |          15 | |                          
                   23 | |        16 | | |    10         5 4       0
                    | | |         | | | |     |         | |       |
   1 1 0 0 0 1 0 0 0|.|1|. . . . .|0|1|0|. . .|. . . . .|0|. . . .|
                    |   |           | | |     |           |
                    |   `-Zm        | | `-Pg  `-Rn        `-prfop
                    `-xs            | `-msz<0>
                                    `-msz<1>
  
  
 
.SS 32-bit unpacked scaled offset
 
 PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer level = UInt(prfop<2:1>);
 boolean stream = (prfop<0> == '1');
 pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
 integer offs_size = 32;
 boolean offs_unsigned = (xs == '0');
 integer scale = 2;
.SS 64-bit scaled offset - A64 - prfw_i_p_bz_d_64_scaled
 
                                       13                          
                                     14 |                          
                                   15 | |                          
                       21        16 | | |    10         5 4       0
                        |         | | | |     |         | |       |
   1 1 0 0 0 1 0 0 0 1 1|. . . . .|1|1|0|. . .|. . . . .|0|. . . .|
                        |           | | |     |           |
                        `-Zm        | | `-Pg  `-Rn        `-prfop
                                    | `-msz<0>
                                    `-msz<1>
  
  
 
.SS 64-bit scaled offset
 
 PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer level = UInt(prfop<2:1>);
 boolean stream = (prfop<0> == '1');
 pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
 integer offs_size = 64;
 boolean offs_unsigned = TRUE;
 integer scale = 2;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(64) base;
 bits(64) addr;
 bits(VL) offset;
 
 if n == 31 then
     base = SP[];
 else
     base = X[n];
 offset = Z[m];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         Hint_Prefetch(addr, pref_hint, level, stream);
 

.SS Assembler Symbols

 <prfop>
  Encoded in prfop
  Is the prefetch operation specifier,

  prfop <prfop>   
  0000  PLDL1KEEP 
  0001  PLDL1STRM 
  0010  PLDL2KEEP 
  0011  PLDL2STRM 
  0100  PLDL3KEEP 
  0101  PLDL3STRM 
  x11x  #uimm4    
  1000  PSTL1KEEP 
  1001  PSTL1STRM 
  1010  PSTL2KEEP 
  1011  PSTL2STRM 
  1100  PSTL3KEEP 
  1101  PSTL3STRM 

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Zm>
  Encoded in Zm
  Is the name of the offset scalable vector register, encoded in the "Zm" field.

 <mod>
  Encoded in xs
  Is the index extend and shift specifier,

  xs <mod> 
  0  UXTW  
  1  SXTW  



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(64) base;
 bits(64) addr;
 bits(VL) offset;
 
 if n == 31 then
     base = SP[];
 else
     base = X[n];
 offset = Z[m];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         Hint_Prefetch(addr, pref_hint, level, stream);

