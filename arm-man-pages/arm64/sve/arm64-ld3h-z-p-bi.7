.nh
.TH "LD3H (scalar plus immediate)" "7" " "  "instruction" "sve"
.SS LD3H (scalar plus immediate)
 Contiguous load three-halfword structures to three vectors (immediate index)

 Contiguous load three-halfword structures, each to the same element number in
 three vector registers from the memory address generated by a 64-bit scalar
 base and an immediate index which is a multiple of 3 in the range -24 to 21
 that is multiplied by the vector's in-memory size, irrespective of predication,

 Each predicate element applies to the same element number in each of the three
 vector registers, or equivalently to the three consecutive halfwords in memory
 which make up each structure. Inactive elements will not read Device memory or
 signal a fault, and the corresponding element is set to zero in each of the
 three destination vector registers.

 Status : Green

 Predicated : True



.SS SVE - A64 - ld3h_z_p_bi_contiguous
 
                                                                   
                   23                                              
                 24 |    20                                        
               25 | |  21 |      16    13    10         5         0
                | | |   | |       |     |     |         |         |
   1 0 1 0 0 1 0|0|1|1 0|0|. . . .|1 1 1|. . .|. . . . .|. . . . .|
                | | |     |             |     |         |
                | | `-opc `-imm4        `-Pg  `-Rn      `-Zt
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 16;
 integer offset = SInt(imm4);
 integer nreg = 3;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 constant integer mbytes = esize DIV 8;
 array [0..2] of bits(VL) values;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * nreg * mbytes;
 for e = 0 to elements-1
     for r = 0 to nreg-1
         if ElemP[mask, e, esize] == '1' then
             Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
         else
             Elem[values[r], e, esize] = Zeros();
         addr = addr + mbytes;
 
 for r = 0 to nreg-1
     Z[(t+r) MOD 32] = values[r];
 

.SS Assembler Symbols

 <Zt1>
  Encoded in Zt
  Is the name of the first scalable vector register to be transferred, encoded
  in the "Zt" field.

 <Zt2>
  Encoded in Zt
  Is the name of the second scalable vector register to be transferred, encoded
  as "Zt" plus 1 modulo 32.

 <Zt3>
  Encoded in Zt
  Is the name of the third scalable vector register to be transferred, encoded
  as "Zt" plus 2 modulo 32.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm4
  Is the optional signed immediate vector offset, a multiple of 3 in the range
  -24 to 21, defaulting to 0, encoded in the "imm4" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 constant integer mbytes = esize DIV 8;
 array [0..2] of bits(VL) values;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * nreg * mbytes;
 for e = 0 to elements-1
     for r = 0 to nreg-1
         if ElemP[mask, e, esize] == '1' then
             Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
         else
             Elem[values[r], e, esize] = Zeros();
         addr = addr + mbytes;
 
 for r = 0 to nreg-1
     Z[(t+r) MOD 32] = values[r];

