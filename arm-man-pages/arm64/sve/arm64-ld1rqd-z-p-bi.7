.nh
.TH "LD1RQD (scalar plus immediate)" "7" " "  "instruction" "sve"
.SS LD1RQD (scalar plus immediate)
 Contiguous load and replicate two doublewords (immediate index)

 Load two contiguous doublewords to elements of a short, 128-bit (quadword)
 vector from the memory address generated by a 64-bit scalar base address and
 immediate index that is a multiple of 16 in the range -128 to +112 added to the
 base address.

 Inactive elements will not read Device memory or signal a fault, and are set to
 zero. The resulting short vector is then replicated to fill the long
 destination vector. Only the first two predicate elements are used and higher
 numbered predicate elements are ignored.

 Status : Green

 Predicated : True



.SS SVE - A64 - ld1rqd_z_p_bi_u64
 
                                                                   
                   23                                              
                 24 |    20                                        
               25 | |  21 |      16    13    10         5         0
                | | |   | |       |     |     |         |         |
   1 0 1 0 0 1 0|1|1|0 0|0|. . . .|0 0 1|. . .|. . . . .|. . . . .|
                | | |     |             |     |         |
                | | `-ssz `-imm4        `-Pg  `-Rn      `-Zt
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 64;
 integer offset = SInt(imm4);
 
 CheckSVEEnabled();
 integer elements = 128 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low 16 bits only
 bits(128) result;
 constant integer mbytes = esize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * 16;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = Replicate(result, VL DIV 128);
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm4
  Is the optional signed immediate byte offset, a multiple of 16 in the range
  -128 to 112, defaulting to 0, encoded in the "imm4" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = 128 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low 16 bits only
 bits(128) result;
 constant integer mbytes = esize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * 16;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = Replicate(result, VL DIV 128);

