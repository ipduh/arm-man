.nh
.TH "UCVTF" "7" " "  "instruction" "sve"
.SS UCVTF
 Unsigned integer convert to floating-point (predicated)

 Convert to floating-point from the unsigned integer in each active element of
 the source vector, and place the results in the corresponding elements of the
 destination vector. Inactive elements in the destination vector register remain
 unmodified.

 If the input and result types have a different size the smaller type is held
 unpacked in the least significant bits of elements of the larger size. When the
 input is the smaller type the upper bits of each source element are ignored.
 When the result is the smaller type the results are zero-extended to fill each
 destination element.

 Status : Green

 Predicated : True

 takes_pred_movprfx : True


It has encodings from 7 classes: 16-bit to half-precision, 32-bit to half-precision, 32-bit to single-precision, 32-bit to double-precision, 64-bit to half-precision, 64-bit to single-precision and 64-bit to double-precision

.SS 16-bit to half-precision - A64 - ucvtf_z_p_z_h2fp16
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|0|1|0 1 0|0|1|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 16-bit to half-precision
 
 UCVTF   <Zd>.H, <Pg>/M, <Zn>.H
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 16;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 16;
 integer d_esize = 16;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 32-bit to half-precision - A64 - ucvtf_z_p_z_w2fp16
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|0|1|0 1 0|1|0|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 32-bit to half-precision
 
 UCVTF   <Zd>.H, <Pg>/M, <Zn>.S
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 32;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 32;
 integer d_esize = 16;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 32-bit to single-precision - A64 - ucvtf_z_p_z_w2s
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|1|0|0 1 0|1|0|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 32-bit to single-precision
 
 UCVTF   <Zd>.S, <Pg>/M, <Zn>.S
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 32;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 32;
 integer d_esize = 32;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 32-bit to double-precision - A64 - ucvtf_z_p_z_w2d
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|1|1|0 1 0|0|0|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 32-bit to double-precision
 
 UCVTF   <Zd>.D, <Pg>/M, <Zn>.S
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 32;
 integer d_esize = 64;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 64-bit to half-precision - A64 - ucvtf_z_p_z_x2fp16
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|0|1|0 1 0|1|1|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 64-bit to half-precision
 
 UCVTF   <Zd>.H, <Pg>/M, <Zn>.D
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 64;
 integer d_esize = 16;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 64-bit to single-precision - A64 - ucvtf_z_p_z_x2s
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|1|1|0 1 0|1|0|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 64-bit to single-precision
 
 UCVTF   <Zd>.S, <Pg>/M, <Zn>.D
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 64;
 integer d_esize = 32;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
.SS 64-bit to double-precision - A64 - ucvtf_z_p_z_x2d
 
                                 16                                
                     22        17 |                                
                   23 |      18 | |                                
                 24 | |    19 | | |    13    10         5         0
                  | | |     | | | |     |     |         |         |
   0 1 1 0 0 1 0 1|1|1|0 1 0|1|1|1|1 0 1|. . .|. . . . .|. . . . .|
                  | |       | | |       |     |         |
                  | |       | | `-int_U `-Pg  `-Zn      `-Zd
                  | |       | `-opc2<0>
                  | |       `-opc2<1>
                  | `-opc<0>
                  `-opc<1>
  
  
 
.SS 64-bit to double-precision
 
 UCVTF   <Zd>.D, <Pg>/M, <Zn>.D
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 64;
 integer g = UInt(Pg);
 integer n = UInt(Zn);
 integer d = UInt(Zd);
 integer s_esize = 64;
 integer d_esize = 64;
 boolean unsigned = TRUE;
 FPRounding rounding = FPRoundingMode(FPCR);
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(VL) operand  = Z[n];
 bits(VL) result = Z[d];
 
 for e = 0 to elements-1
     bits(esize) element = Elem[operand, e, esize];
     if ElemP[mask, e, esize] == '1' then
         bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
         Elem[result, e, esize] = ZeroExtend(fpval);
 
 Z[d] = result;
 

.SS Assembler Symbols

 <Zd>
  Encoded in Zd
  Is the name of the destination scalable vector register, encoded in the "Zd"
  field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Zn>
  Encoded in Zn
  Is the name of the source scalable vector register, encoded in the "Zn" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(VL) operand  = Z[n];
 bits(VL) result = Z[d];
 
 for e = 0 to elements-1
     bits(esize) element = Elem[operand, e, esize];
     if ElemP[mask, e, esize] == '1' then
         bits(d_esize) fpval = FixedToFP(element<s_esize-1:0>, 0, unsigned, FPCR, rounding);
         Elem[result, e, esize] = ZeroExtend(fpval);
 
 Z[d] = result;

