.nh
.TH "PRFW (scalar plus immediate)" "7" " "  "instruction" "sve"
.SS PRFW (scalar plus immediate)
 Contiguous prefetch words (immediate index)

 Contiguous prefetch of word elements from the memory address generated by a
 64-bit scalar base and immediate index in the range -32 to 31 which is
 multiplied by the vector's in-memory size, irrespective of predication, and
 added to the base address.

 The predicate may be used to suppress prefetches from unwanted addresses.

 Status : Green

 Predicated : True



.SS SVE - A64 - prfw_i_p_bi_s
 
                                       13                          
                                     14 |                          
                                   15 | |                          
                     22          16 | | |    10         5 4       0
                      |           | | | |     |         | |       |
   1 0 0 0 0 1 0 1 1 1|. . . . . .|0|1|0|. . .|. . . . .|0|. . . .|
                      |             | | |     |           |
                      `-imm6        | | `-Pg  `-Rn        `-prfop
                                    | `-msz<0>
                                    `-msz<1>
  
  
 
.SS SVE
 
 PRFW    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer esize = 32;
 integer g = UInt(Pg);
 integer n = UInt(Rn);
 integer level = UInt(prfop<2:1>);
 boolean stream = (prfop<0> == '1');
 pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
 integer scale = 2;
 integer offset = SInt(imm6);
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(64) base;
 bits(64) addr;
 
 if n == 31 then
     base = SP[];
 else
     base = X[n];
 
 addr = base + ((offset * elements) << scale);
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Hint_Prefetch(addr, pref_hint, level, stream);
     addr = addr + (1 << scale);
 

.SS Assembler Symbols

 <prfop>
  Encoded in prfop
  Is the prefetch operation specifier,

  prfop <prfop>   
  0000  PLDL1KEEP 
  0001  PLDL1STRM 
  0010  PLDL2KEEP 
  0011  PLDL2STRM 
  0100  PLDL3KEEP 
  0101  PLDL3STRM 
  x11x  #uimm4    
  1000  PSTL1KEEP 
  1001  PSTL1STRM 
  1010  PSTL2KEEP 
  1011  PSTL2STRM 
  1100  PSTL3KEEP 
  1101  PSTL3STRM 

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm6
  Is the optional signed immediate vector offset, in the range -32 to 31,
  defaulting to 0, encoded in the "imm6" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(PL) mask = P[g];
 bits(64) base;
 bits(64) addr;
 
 if n == 31 then
     base = SP[];
 else
     base = X[n];
 
 addr = base + ((offset * elements) << scale);
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Hint_Prefetch(addr, pref_hint, level, stream);
     addr = addr + (1 << scale);

