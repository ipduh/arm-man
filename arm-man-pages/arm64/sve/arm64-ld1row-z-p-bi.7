.nh
.TH "LD1ROW (scalar plus immediate)" "7" " "  "instruction" "sve"
.SS LD1ROW (scalar plus immediate)
 Contiguous load and replicate eight words (immediate index)

 Load eight contiguous words to elements of a 256-bit (octaword) vector from the
 memory address generated by a 64-bit scalar base address and immediate index
 that is a multiple of 32 in the range -256 to +224 added to the base address.

 Inactive elements will not read Device memory or signal a fault, and are set to
 zero.

 The resulting 256-bit vector is then replicated to fill the destination vector.
 The instruction requires that the current vector length is at least 256 bits,
 and if the current vector length is not an integer multiple of 256 bits then
 the trailing bits in the destination vector are set to zero.

 Only the first eight predicate elements are used and higher numbered predicate
 elements are ignored.

 ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

 Status : Amber

 Predicated : True



.SS SVE - A64 - ld1row_z_p_bi_u32
 
                                                                   
                   23                                              
                 24 |    20                                        
               25 | |  21 |      16    13    10         5         0
                | | |   | |       |     |     |         |         |
   1 0 1 0 0 1 0|1|0|0 1|0|. . . .|0 0 1|. . .|. . . . .|. . . . .|
                | | |     |             |     |         |
                | | `-ssz `-imm4        `-Pg  `-Rn      `-Zt
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
 
 if !HaveSVEFP64MatMulExt() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 32;
 integer offset = SInt(imm4);
 
 CheckSVEEnabled();
 if VL < 256 then UNDEFINED;
 integer elements = 256 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low bits only
 bits(256) result;
 constant integer mbytes = esize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * 32;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm4
  Is the optional signed immediate byte offset, a multiple of 32 in the range
  -256 to 224, defaulting to 0, encoded in the "imm4" field.



.SS Operation

 CheckSVEEnabled();
 if VL < 256 then UNDEFINED;
 integer elements = 256 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low bits only
 bits(256) result;
 constant integer mbytes = esize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * 32;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);

