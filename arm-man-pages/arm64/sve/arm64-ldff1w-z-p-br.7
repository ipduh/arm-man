.nh
.TH "LDFF1W (scalar plus scalar)" "7" " "  "instruction" "sve"
.SS LDFF1W (scalar plus scalar)
 Contiguous load first-fault unsigned words to vector (scalar index)

 Contiguous load with first-faulting behavior of unsigned words to elements of a
 vector register from the memory address generated by a 64-bit scalar base and
 scalar index which is multiplied by 4 and added to the base address. After each
 element access the index value is incremented, but the index register is not
 updated. Inactive elements will not read Device memory or signal a fault, and
 are set to zero in the destination vector.

 Status : Green

 Predicated : True


It has encodings from 2 classes: 32-bit element and 64-bit element

.SS 32-bit element - A64 - ldff1w_z_p_br_u32
 
                                                                   
                                                                   
                       21                                          
               25    22 |        16    13    10         5         0
                |     | |         |     |     |         |         |
   1 0 1 0 0 1 0|1 0 1|0|. . . . .|0 1 1|. . .|. . . . .|. . . . .|
                |     | |               |     |         |
                |     | `-Rm            `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 32-bit element
 
 LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 32;
 boolean unsigned = TRUE;
.SS 64-bit element - A64 - ldff1w_z_p_br_u64
 
                                                                   
                                                                   
                       21                                          
               25    22 |        16    13    10         5         0
                |     | |         |     |     |         |         |
   1 0 1 0 0 1 0|1 0 1|1|. . . . .|0 1 1|. . .|. . . . .|. . . . .|
                |     | |               |     |         |
                |     | `-Rm            `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 64-bit element
 
 LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 32;
 boolean unsigned = TRUE;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 bits(64) offset = X[m];
 constant integer mbytes = msize DIV 8;
 boolean first = TRUE;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         addr = base + UInt(offset) * mbytes;
         if first then
             // Mem[] will not return if a fault is detected for the first active element
             data = Mem[addr, mbytes, AccType_NORMAL];
             first = FALSE;
         else
             // MemNF[] will return fault=TRUE if access is not performed for any reason
             (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
     offset = offset + 1;
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Xm>
  Encoded in Rm
  Is the optional 64-bit name of the general-purpose offset register, defaulting
  to XZR, encoded in the "Rm" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 bits(64) offset = X[m];
 constant integer mbytes = msize DIV 8;
 boolean first = TRUE;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         addr = base + UInt(offset) * mbytes;
         if first then
             // Mem[] will not return if a fault is detected for the first active element
             data = Mem[addr, mbytes, AccType_NORMAL];
             first = FALSE;
         else
             // MemNF[] will return fault=TRUE if access is not performed for any reason
             (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
     offset = offset + 1;
 
 Z[t] = result;

