.nh
.TH "LD1H (scalar plus vector)" "7" " "  "instruction" "sve"
.SS LD1H (scalar plus vector)
 Gather load unsigned halfwords to vector (vector index)

 Gather load of unsigned halfwords to active elements of a vector register from
 memory addresses generated by a 64-bit scalar base plus vector index. The index
 values are optionally first sign or zero-extended from 32 to 64 bits and then
 optionally multiplied by 2. Inactive elements will not read Device memory or
 signal faults, and are set to zero in the destination vector.

 Status : Green

 Predicated : True


It has encodings from 6 classes: 32-bit scaled offset, 32-bit unpacked scaled offset, 32-bit unpacked unscaled offset, 32-bit unscaled offset, 64-bit scaled offset and 64-bit unscaled offset

.SS 32-bit scaled offset - A64 - ld1h_z_p_bz_s_x32_scaled
 
                                       13                          
                       21            14 |                          
                     22 |          15 | |                          
                   23 | |        16 | | |    10         5         0
                    | | |         | | | |     |         |         |
   1 0 0 0 0 1 0 0 1|.|1|. . . . .|0|1|0|. . .|. . . . .|. . . . .|
                    |   |           | | |     |         |
                    |   `-Zm        | | `-Pg  `-Rn      `-Zt
                    `-xs            | `-ff
                                    `-U
  
  
 
.SS 32-bit scaled offset
 
 LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 16;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 1;
.SS 32-bit unpacked scaled offset - A64 - ld1h_z_p_bz_d_x32_scaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 1 0 0 0 1 0|0|1|.|1|. . . . .|0|1|0|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-opc             `-U
                `-opc<1>
  
  
 
.SS 32-bit unpacked scaled offset
 
 LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 16;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 1;
.SS 32-bit unpacked unscaled offset - A64 - ld1h_z_p_bz_d_x32_unscaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 1 0 0 0 1 0|0|1|.|0|. . . . .|0|1|0|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-msz<0>          `-U
                `-msz<1>
  
  
 
.SS 32-bit unpacked unscaled offset
 
 LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 16;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 0;
.SS 32-bit unscaled offset - A64 - ld1h_z_p_bz_s_x32_unscaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 0 0 0 0 1 0|0|1|.|0|. . . . .|0|1|0|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-opc<0>          `-U
                `-opc<1>
  
  
 
.SS 32-bit unscaled offset
 
 LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 16;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 0;
.SS 64-bit scaled offset - A64 - ld1h_z_p_bz_d_64_scaled
 
                                       13                          
                   23                14 |                          
                 24 |              15 | |                          
               25 | |  21        16 | | |    10         5         0
                | | |   |         | | | |     |         |         |
   1 1 0 0 0 1 0|0|1|1 1|. . . . .|1|1|0|. . .|. . . . .|. . . . .|
                | |     |           | | |     |         |
                | `-opc `-Zm        | | `-Pg  `-Rn      `-Zt
                `-opc<1>            | `-ff
                                    `-U
  
  
 
.SS 64-bit scaled offset
 
 LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 16;
 integer offs_size = 64;
 boolean unsigned = TRUE;
 boolean offs_unsigned = TRUE;
 integer scale = 1;
.SS 64-bit unscaled offset - A64 - ld1h_z_p_bz_d_64_unscaled
 
                                       13                          
                   23                14 |                          
                 24 |              15 | |                          
               25 | |  21        16 | | |    10         5         0
                | | |   |         | | | |     |         |         |
   1 1 0 0 0 1 0|0|1|1 0|. . . . .|1|1|0|. . .|. . . . .|. . . . .|
                | |     |           | | |     |         |
                | |     `-Zm        | | `-Pg  `-Rn      `-Zt
                | `-msz<0>          | `-ff
                `-msz<1>            `-U
  
  
 
.SS 64-bit unscaled offset
 
 LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 16;
 integer offs_size = 64;
 boolean unsigned = TRUE;
 boolean offs_unsigned = TRUE;
 integer scale = 0;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(VL) offset = Z[m];
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         data = Mem[addr, mbytes, AccType_NORMAL];
         Elem[result, e, esize] = Extend(data, esize, unsigned);
     else
         Elem[result, e, esize] = Zeros();
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Zm>
  Encoded in Zm
  Is the name of the offset scalable vector register, encoded in the "Zm" field.

 <mod>
  Encoded in xs
  Is the index extend and shift specifier,

  xs <mod> 
  0  UXTW  
  1  SXTW  



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(VL) offset = Z[m];
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         data = Mem[addr, mbytes, AccType_NORMAL];
         Elem[result, e, esize] = Extend(data, esize, unsigned);
     else
         Elem[result, e, esize] = Zeros();
 
 Z[t] = result;

