.nh
.TH "LD1RQW (scalar plus scalar)" "7" " "  "instruction" "sve"
.SS LD1RQW (scalar plus scalar)
 Contiguous load and replicate four words (scalar index)

 Load four contiguous words to elements of a short, 128-bit (quadword) vector
 from the memory address generated by a 64-bit scalar base address and scalar
 index which is multiplied by 4 and added to the base address.

 Inactive elements will not read Device memory or signal a fault, and are set to
 zero. The resulting short vector is then replicated to fill the long
 destination vector. Only the first four predicate elements are used and higher
 numbered predicate elements are ignored.

 Status : Green

 Predicated : True



.SS SVE - A64 - ld1rqw_z_p_br_contiguous
 
                                                                   
                   23                                              
                 24 |                                              
               25 | |  21        16    13    10         5         0
                | | |   |         |     |     |         |         |
   1 0 1 0 0 1 0|1|0|0 0|. . . . .|0 0 0|. . .|. . . . .|. . . . .|
                | | |   |               |     |         |
                | | |   `-Rm            `-Pg  `-Rn      `-Zt
                | | `-ssz
                | `-msz<0>
                `-msz<1>
  
  
 
.SS SVE
 
 LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
 
 if !HaveSVE() then UNDEFINED;
 if Rm == '11111' then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 integer g = UInt(Pg);
 integer esize = 32;
 
 CheckSVEEnabled();
 integer elements = 128 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low 16 bits only
 bits(64) offset;
 bits(128) result;
 constant integer mbytes = esize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 offset = X[m];
 
 addr = base + UInt(offset) * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = Replicate(result, VL DIV 128);
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Xm>
  Encoded in Rm
  Is the 64-bit name of the general-purpose offset register, encoded in the "Rm"
  field.



.SS Operation

 CheckSVEEnabled();
 integer elements = 128 DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g]; // low 16 bits only
 bits(64) offset;
 bits(128) result;
 constant integer mbytes = esize DIV 8;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 offset = X[m];
 
 addr = base + UInt(offset) * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = Replicate(result, VL DIV 128);

