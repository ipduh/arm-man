.nh
.TH "LDNF1SB" "7" " "  "instruction" "sve"
.SS LDNF1SB
 Contiguous load non-fault signed bytes to vector (immediate index)

 Contiguous load with non-faulting behavior of signed bytes to elements of a
 vector register from the memory address generated by a 64-bit scalar base and
 immediate index in the range -8 to 7 which is multiplied by the vector's in-
 memory size, irrespective of predication, and added to the base address.
 Inactive elements will not read Device memory or signal a fault, and are set to
 zero in the destination vector.

 Status : Green

 Predicated : True


It has encodings from 3 classes: 16-bit element, 32-bit element and 64-bit element

.SS 16-bit element - A64 - ldnf1sb_z_p_bi_s16
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|1 1 1|0|1|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 16-bit element
 
 LDNF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 16;
 integer msize = 8;
 boolean unsigned = FALSE;
 integer offset = SInt(imm4);
.SS 32-bit element - A64 - ldnf1sb_z_p_bi_s32
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|1 1 0|1|1|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 32-bit element
 
 LDNF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 8;
 boolean unsigned = FALSE;
 integer offset = SInt(imm4);
.SS 64-bit element - A64 - ldnf1sb_z_p_bi_s64
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|1 1 0|0|1|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 64-bit element
 
 LDNF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 8;
 boolean unsigned = FALSE;
 integer offset = SInt(imm4);
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         // MemNF[] will return fault=TRUE if access is not performed for any reason
         (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
     addr = addr + mbytes;
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm4
  Is the optional signed immediate vector offset, in the range -8 to 7,
  defaulting to 0, encoded in the "imm4" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         // MemNF[] will return fault=TRUE if access is not performed for any reason
         (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
     addr = addr + mbytes;
 
 Z[t] = result;

