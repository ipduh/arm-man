.nh
.TH "LDFF1W (scalar plus vector)" "7" " "  "instruction" "sve"
.SS LDFF1W (scalar plus vector)
 Gather load first-fault unsigned words to vector (vector index)

 Gather load with first-faulting behavior of unsigned words to active elements
 of a vector register from memory addresses generated by a 64-bit scalar base
 plus vector index. The index values are optionally first sign or zero-extended
 from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will
 not read Device memory or signal faults, and are set to zero in the destination
 vector.

 Status : Green

 Predicated : True


It has encodings from 6 classes: 32-bit scaled offset, 32-bit unpacked scaled offset, 32-bit unpacked unscaled offset, 32-bit unscaled offset, 64-bit scaled offset and 64-bit unscaled offset

.SS 32-bit scaled offset - A64 - ldff1w_z_p_bz_s_x32_scaled
 
                                       13                          
                       21            14 |                          
                     22 |          15 | |                          
                   23 | |        16 | | |    10         5         0
                    | | |         | | | |     |         |         |
   1 0 0 0 0 1 0 1 0|.|1|. . . . .|0|1|1|. . .|. . . . .|. . . . .|
                    |   |           | | |     |         |
                    |   `-Zm        | | `-Pg  `-Rn      `-Zt
                    `-xs            | `-ff
                                    `-U
  
  
 
.SS 32-bit scaled offset
 
 LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 32;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 2;
.SS 32-bit unpacked scaled offset - A64 - ldff1w_z_p_bz_d_x32_scaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 1 0 0 0 1 0|1|0|.|1|. . . . .|0|1|1|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-opc<0>          `-U
                `-opc<1>
  
  
 
.SS 32-bit unpacked scaled offset
 
 LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 32;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 2;
.SS 32-bit unpacked unscaled offset - A64 - ldff1w_z_p_bz_d_x32_unscaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 1 0 0 0 1 0|1|0|.|0|. . . . .|0|1|1|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-msz<0>          `-U
                `-msz<1>
  
  
 
.SS 32-bit unpacked unscaled offset
 
 LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 32;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 0;
.SS 32-bit unscaled offset - A64 - ldff1w_z_p_bz_s_x32_unscaled
 
                     22                13                          
                   23 |              14 |                          
                 24 | |            15 | |                          
               25 | | |21        16 | | |    10         5         0
                | | | | |         | | | |     |         |         |
   1 0 0 0 0 1 0|1|0|.|0|. . . . .|0|1|1|. . .|. . . . .|. . . . .|
                | | |   |           | | |     |         |
                | | |   `-Zm        | | `-Pg  `-Rn      `-Zt
                | | `-xs            | `-ff
                | `-opc             `-U
                `-opc<1>
  
  
 
.SS 32-bit unscaled offset
 
 LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 32;
 integer offs_size = 32;
 boolean unsigned = TRUE;
 boolean offs_unsigned = xs == '0';
 integer scale = 0;
.SS 64-bit scaled offset - A64 - ldff1w_z_p_bz_d_64_scaled
 
                                       13                          
                   23                14 |                          
                 24 |              15 | |                          
               25 | |  21        16 | | |    10         5         0
                | | |   |         | | | |     |         |         |
   1 1 0 0 0 1 0|1|0|1 1|. . . . .|1|1|1|. . .|. . . . .|. . . . .|
                | |     |           | | |     |         |
                | |     `-Zm        | | `-Pg  `-Rn      `-Zt
                | `-opc<0>          | `-ff
                `-opc<1>            `-U
  
  
 
.SS 64-bit scaled offset
 
 LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 32;
 integer offs_size = 64;
 boolean unsigned = TRUE;
 boolean offs_unsigned = TRUE;
 integer scale = 2;
.SS 64-bit unscaled offset - A64 - ldff1w_z_p_bz_d_64_unscaled
 
                                       13                          
                   23                14 |                          
                 24 |              15 | |                          
               25 | |  21        16 | | |    10         5         0
                | | |   |         | | | |     |         |         |
   1 1 0 0 0 1 0|1|0|1 0|. . . . .|1|1|1|. . .|. . . . .|. . . . .|
                | |     |           | | |     |         |
                | |     `-Zm        | | `-Pg  `-Rn      `-Zt
                | `-msz<0>          | `-ff
                `-msz<1>            `-U
  
  
 
.SS 64-bit unscaled offset
 
 LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer m = UInt(Zm);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 32;
 integer offs_size = 64;
 boolean unsigned = TRUE;
 boolean offs_unsigned = TRUE;
 integer scale = 0;
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(VL) offset;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 boolean first = TRUE;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 offset = Z[m];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         if first then
             // Mem[] will not return if a fault is detected for the first active element
             data = Mem[addr, mbytes, AccType_NORMAL];
             first = FALSE;
         else
             // MemNF[] will return fault=TRUE if access is not performed for any reason
             (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <Zm>
  Encoded in Zm
  Is the name of the offset scalable vector register, encoded in the "Zm" field.

 <mod>
  Encoded in xs
  Is the index extend and shift specifier,

  xs <mod> 
  0  UXTW  
  1  SXTW  



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(VL) offset;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(VL) orig = Z[t];
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 boolean first = TRUE;
 boolean fault = FALSE;
 boolean faulted = FALSE;
 boolean unknown = FALSE;
 
 if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
 
 if n == 31 then
     CheckSPAlignment();
     base = SP[];
 else
     base = X[n];
 offset = Z[m];
 
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         integer off = Int(Elem[offset, e, esize]<offs_size-1:0>, offs_unsigned);
         addr = base + (off << scale);
         if first then
             // Mem[] will not return if a fault is detected for the first active element
             data = Mem[addr, mbytes, AccType_NORMAL];
             first = FALSE;
         else
             // MemNF[] will return fault=TRUE if access is not performed for any reason
             (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
     else
         (data, fault) = (Zeros(msize), FALSE);
 
     // FFR elements set to FALSE following a supressed access/fault
     faulted = faulted || fault;
     if faulted then
         ElemFFR[e, esize] = '0';
 
     // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
     unknown = unknown || ElemFFR[e, esize] == '0';
     if unknown then
         if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
             Elem[result, e, esize] = Extend(data, esize, unsigned);
         elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
             Elem[result, e, esize] = Zeros();
         else  // merge
             Elem[result, e, esize] = Elem[orig, e, esize];
     else
         Elem[result, e, esize] = Extend(data, esize, unsigned);
 
 Z[t] = result;

