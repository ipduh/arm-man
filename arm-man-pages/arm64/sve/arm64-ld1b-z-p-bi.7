.nh
.TH "LD1B (scalar plus immediate)" "7" " "  "instruction" "sve"
.SS LD1B (scalar plus immediate)
 Contiguous load unsigned bytes to vector (immediate index)

 Contiguous load of unsigned bytes to elements of a vector register from the
 memory address generated by a 64-bit scalar base and immediate index in the
 range -8 to 7 which is multiplied by the vector's in-memory size, irrespective
 of predication, and added to the base address. Inactive elements will not read
 Device memory or signal a fault, and are set to zero in the destination vector.

 Status : Green

 Predicated : True


It has encodings from 4 classes: 8-bit element, 16-bit element, 32-bit element and 64-bit element

.SS 8-bit element - A64 - ld1b_z_p_bi_u8
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|0 0 0|0|0|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 8-bit element
 
 LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 8;
 integer msize = 8;
 boolean unsigned = TRUE;
 integer offset = SInt(imm4);
.SS 16-bit element - A64 - ld1b_z_p_bi_u16
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|0 0 0|1|0|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 16-bit element
 
 LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 16;
 integer msize = 8;
 boolean unsigned = TRUE;
 integer offset = SInt(imm4);
.SS 32-bit element - A64 - ld1b_z_p_bi_u32
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|0 0 1|0|0|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 32-bit element
 
 LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 32;
 integer msize = 8;
 boolean unsigned = TRUE;
 integer offset = SInt(imm4);
.SS 64-bit element - A64 - ld1b_z_p_bi_u64
 
                                                                   
                         20                                        
                       21 |                                        
               25    22 | |      16    13    10         5         0
                |     | | |       |     |     |         |         |
   1 0 1 0 0 1 0|0 0 1|1|0|. . . .|1 0 1|. . .|. . . . .|. . . . .|
                |     |   |             |     |         |
                |     |   `-imm4        `-Pg  `-Rn      `-Zt
                |     `-dtype<0>
                `-dtype<3:1>
  
  
 
.SS 64-bit element
 
 LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
 
 if !HaveSVE() then UNDEFINED;
 integer t = UInt(Zt);
 integer n = UInt(Rn);
 integer g = UInt(Pg);
 integer esize = 64;
 integer msize = 8;
 boolean unsigned = TRUE;
 integer offset = SInt(imm4);
 
 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         data = Mem[addr, mbytes, AccType_NORMAL];
         Elem[result, e, esize] = Extend(data, esize, unsigned);
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = result;
 

.SS Assembler Symbols

 <Zt>
  Encoded in Zt
  Is the name of the scalable vector register to be transferred, encoded in the
  "Zt" field.

 <Pg>
  Encoded in Pg
  Is the name of the governing scalable predicate register P0-P7, encoded in the
  "Pg" field.

 <Xn|SP>
  Encoded in Rn
  Is the 64-bit name of the general-purpose base register or stack pointer,
  encoded in the "Rn" field.

 <imm>
  Encoded in imm4
  Is the optional signed immediate vector offset, in the range -8 to 7,
  defaulting to 0, encoded in the "imm4" field.



.SS Operation

 CheckSVEEnabled();
 integer elements = VL DIV esize;
 bits(64) base;
 bits(64) addr;
 bits(PL) mask = P[g];
 bits(VL) result;
 bits(msize) data;
 constant integer mbytes = msize DIV 8;
 
 if n == 31 then
     CheckSPAlignment();
     if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
     base = SP[];
 else
     if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
     base = X[n];
 
 addr = base + offset * elements * mbytes;
 for e = 0 to elements-1
     if ElemP[mask, e, esize] == '1' then
         data = Mem[addr, mbytes, AccType_NORMAL];
         Elem[result, e, esize] = Extend(data, esize, unsigned);
     else
         Elem[result, e, esize] = Zeros();
     addr = addr + mbytes;
 
 Z[t] = result;

