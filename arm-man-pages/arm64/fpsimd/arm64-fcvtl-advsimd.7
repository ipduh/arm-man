.nh
.TH "FCVTL, FCVTL2 -- A64" "7" " "  "instruction" "advsimd"
.SS FCVTL, FCVTL2
 Floating-point Convert to higher precision Long (vector)

 Floating-point Convert to higher precision Long (vector). This instruction
 reads each element in a vector in the SIMD&FP source register, converts each
 value to double the precision of the source element using the rounding mode
 that is determined by the FPCR, and writes each result to the equivalent
 element of the vector in the SIMD&FP destination register.

 Where the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2
 variant operates on the elements in the top 64 bits of the source register.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the current Security state and Exception level, an attempt to execute the
 instruction might be trapped.



.SS Vector single-precision and double-precision - A64 - FCVTL_asimdmisc_L
 
                                                                   
       29            22                                            
     30 |          23 |                                            
   31 | |        24 | |        17        12  10         5         0
    | | |         | | |         |         |   |         |         |
   0|.|0|0 1 1 1 0|0|.|1 0 0 0 0|1 0 1 1 1|1 0|. . . . .|. . . . .|
    | |             |           |             |         |
    | `-U           `-sz        `-opcode      `-Rn      `-Rd
    `-Q
  
  
 
.SS Vector single-precision and double-precision
 
 FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>
 
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 
 integer esize = 16 << UInt(sz);
 integer datasize = 64;
 integer part = UInt(Q);
 integer elements = datasize DIV esize;
 
 CheckFPAdvSIMDEnabled64();
 bits(datasize) operand = Vpart[n, part];
 bits(2*datasize) result;
 
 for e = 0 to elements-1
     Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);
 
 V[d] = result;
 

.SS Assembler Symbols

 2
  Encoded in Q
  Is the second and upper half specifier. If present it causes the operation to
  be performed on the upper 64 bits of the registers holding the narrower
  elements, and is

  Q 2         
  0 [absent]  
  1 [present] 

 <Vd>
  Encoded in Rd
  Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

 <Ta>
  Encoded in sz
  Is an arrangement specifier,

  sz <Ta> 
  0  4S   
  1  2D   

 <Vn>
  Encoded in Rn
  Is the name of the SIMD&FP source register, encoded in the "Rn" field.

 <Tb>
  Encoded in sz:Q
  Is an arrangement specifier,

  sz Q <Tb> 
  0  0 4H   
  0  1 8H   
  1  0 2S   
  1  1 4S   



.SS Operation

 CheckFPAdvSIMDEnabled64();
 bits(datasize) operand = Vpart[n, part];
 bits(2*datasize) result;
 
 for e = 0 to elements-1
     Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);
 
 V[d] = result;

