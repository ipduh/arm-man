.nh
.TH "FCCMPE -- A64" "7" " "  "instruction" "float"
.SS FCCMPE
 Floating-point Conditional signaling Compare (scalar)

 Floating-point Conditional signaling Compare (scalar). This instruction
 compares the two SIMD&FP source register values and writes the result to the
 PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N,
 Z, C, V} flags are set to the flag bit specifier.

 If either operand is any type of NaN, or if either operand is a signaling NaN,
 the instruction raises an Invalid Operation exception.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the current Security state and Exception level, an attempt to execute the
 instruction might be trapped.



.SS Floating-point - A64 - float
 
                                                                   
       29                                                          
     30 |              21                                          
   31 | |        24  22 |        16      12  10         5 4       0
    | | |         |   | |         |       |   |         | |       |
  |0|0|0|1 1 1 1 0|. .|1|. . . . .|. . . .|0 1|. . . . .|1|. . . .|
  |   |           |     |         |           |         | |
  `-M `-S         |     `-Rm      `-cond      `-Rn      | `-nzcv
                  `-ftype                               `-op
  
  
 
.SS Half-precision(ftype == 11)
 
 FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>
.SS Single-precision(ftype == 00)
 
 FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>
.SS Double-precision(ftype == 01)
 
 FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>
 
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 
 integer datasize;
 case ftype of
     when '00' datasize = 32;
     when '01' datasize = 64;
     when '10' UNDEFINED;
     when '11'
         if HaveFP16Ext() then
             datasize = 16;
         else
             UNDEFINED;
 
 boolean signal_all_nans = (op == '1');
 bits(4) condition = cond;
 bits(4) flags = nzcv;
 
 CheckFPAdvSIMDEnabled64();
 
 bits(datasize) operand1 = V[n];
 bits(datasize) operand2;
 
 operand2 = V[m];
 
 if ConditionHolds(condition) then
     flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
 PSTATE.<N,Z,C,V> = flags;
 

.SS Assembler Symbols

 <Dn>
  Encoded in Rn
  Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn"
  field.

 <Dm>
  Encoded in Rm
  Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm"
  field.

 <Hn>
  Encoded in Rn
  Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn"
  field.

 <Hm>
  Encoded in Rm
  Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm"
  field.

 <Sn>
  Encoded in Rn
  Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn"
  field.

 <Sm>
  Encoded in Rm
  Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm"
  field.

 <nzcv>
  Encoded in nzcv
  Is the flag bit specifier, an immediate in the range 0 to 15, giving the
  alternative state for the 4-bit NZCV condition flags, encoded in the "nzcv"
  field.

 <cond>
  Encoded in cond
  Is one of the standard conditions, encoded in the "cond" field in the standard
  way.



.SS Operation

 CheckFPAdvSIMDEnabled64();
 
 bits(datasize) operand1 = V[n];
 bits(datasize) operand2;
 
 operand2 = V[m];
 
 if ConditionHolds(condition) then
     flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
 PSTATE.<N,Z,C,V> = flags;

