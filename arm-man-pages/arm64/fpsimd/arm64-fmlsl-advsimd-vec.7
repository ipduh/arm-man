.nh
.TH "FMLSL, FMLSL2 (vector) -- A64" "7" " "  "instruction" "advsimd"
.SS FMLSL, FMLSL2 (vector)
 Floating-point fused Multiply-Subtract Long from accumulator (vector)

 Floating-point fused Multiply-Subtract Long from accumulator (vector). This
 instruction negates the values in the vector of one SIMD&FP register,
 multiplies these with the corresponding values in another vector, and
 accumulates the product to the corresponding vector element of the destination
 SIMD&FP register. The instruction does not round the result of the multiply
 before the accumulation.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the current Security state and Exception level, an attempt to execute the
 instruction might be trapped.

 In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
 mandatory for all implementations to support it.


It has encodings from 2 classes: FMLSL and FMLSL2

.SS FMLSL - A64 - FMLSL_asimdsame_F
 
                       21                                          
       29            22 |                                          
     30 |          23 | |          15        10                    
   31 | |        24 | | |        16 |      11 |         5         0
    | | |         | | | |         | |       | |         |         |
   0|.|0|0 1 1 1 0|1|0|1|. . . . .|1|1 1 0 1|1|. . . . .|. . . . .|
    | |           | |   |         | |         |         |
    | `-U         | |   `-Rm      | |         `-Rn      `-Rd
    `-Q           | `-sz          | `-opcode[3:0]
                  `-S             `-opcode[4]
  
  
 
.SS FMLSL
 
 FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
 
 if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 if sz == '1' then UNDEFINED;
 integer esize = 32;
 integer datasize = if Q == '1' then 128 else 64;
 integer elements = datasize DIV esize;
 boolean sub_op = (S == '1');
 integer part = 0;
.SS FMLSL2 - A64 - FMLSL2_asimdsame_F
 
                       21                                          
       29            22 |                                          
     30 |          23 | |          15        10                    
   31 | |        24 | | |        16 |      11 |         5         0
    | | |         | | | |         | |       | |         |         |
   0|.|1|0 1 1 1 0|1|0|1|. . . . .|1|1 0 0 1|1|. . . . .|. . . . .|
    | |           | |   |         | |         |         |
    | `-U         | |   `-Rm      | |         `-Rn      `-Rd
    `-Q           | `-sz          | `-opcode[3:0]
                  `-S             `-opcode[4]
  
  
 
.SS FMLSL2
 
 FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>
 
 if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 integer m = UInt(Rm);
 if sz == '1' then UNDEFINED;
 integer esize = 32;
 integer datasize = if Q == '1' then 128 else 64;
 integer elements = datasize DIV esize;
 boolean sub_op = (S == '1');
 integer part = 1;
 
 CheckFPAdvSIMDEnabled64();
 bits(datasize DIV 2) operand1 = Vpart[n,part];
 bits(datasize DIV 2) operand2 = Vpart[m,part];
 bits(datasize) operand3 = V[d];
 bits(datasize) result;
 bits(esize DIV 2) element1;
 bits(esize DIV 2) element2;
 
 for e = 0 to elements-1
     element1 = Elem[operand1, e, esize DIV 2];
     element2 = Elem[operand2, e, esize DIV 2];
     if sub_op then element1 = FPNeg(element1);
     Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
 V[d] = result;
 

.SS Assembler Symbols

 <Vd>
  Encoded in Rd
  Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

 <Ta>
  Encoded in Q
  Is an arrangement specifier,

  Q <Ta> 
  0 2S   
  1 4S   

 <Vn>
  Encoded in Rn
  Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

 <Tb>
  Encoded in Q
  Is an arrangement specifier,

  Q <Tb> 
  0 2H   
  1 4H   

 <Vm>
  Encoded in Rm
  Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



.SS Operation

 CheckFPAdvSIMDEnabled64();
 bits(datasize DIV 2) operand1 = Vpart[n,part];
 bits(datasize DIV 2) operand2 = Vpart[m,part];
 bits(datasize) operand3 = V[d];
 bits(datasize) result;
 bits(esize DIV 2) element1;
 bits(esize DIV 2) element2;
 
 for e = 0 to elements-1
     element1 = Elem[operand1, e, esize DIV 2];
     element2 = Elem[operand2, e, esize DIV 2];
     if sub_op then element1 = FPNeg(element1);
     Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
 V[d] = result;

