.nh
.TH "FCVTN, FCVTN2 -- A64" "7" " "  "instruction" "advsimd"
.SS FCVTN, FCVTN2
 Floating-point Convert to lower precision Narrow (vector)

 Floating-point Convert to lower precision Narrow (vector). This instruction
 reads each vector element in the SIMD&FP source register, converts each result
 to half the precision of the source element, writes the final result to a
 vector, and writes the vector to the lower or upper half of the destination
 SIMD&FP register. The destination vector elements are half as long as the
 source vector elements. The rounding mode is determined by the FPCR.

 The FCVTN instruction writes the vector to the lower half of the destination
 register and clears the upper half, while the FCVTN2 instruction writes the
 vector to the upper half of the destination register without affecting the
 other bits of the register.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the Security state and Exception level in which the instruction is
 executed, an attempt to execute the instruction might be trapped.



.SS Vector single-precision and double-precision - A64 - FCVTN_asimdmisc_N
 
                                                                   
       29            22                                            
     30 |          23 |                                            
   31 | |        24 | |        17        12  10         5         0
    | | |         | | |         |         |   |         |         |
   0|.|0|0 1 1 1 0|0|.|1 0 0 0 0|1 0 1 1 0|1 0|. . . . .|. . . . .|
    | |             |           |             |         |
    | `-U           `-sz        `-opcode      `-Rn      `-Rd
    `-Q
  
  
 
.SS Vector single-precision and double-precision
 
 FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>
 
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 
 integer esize = 16 << UInt(sz);
 integer datasize = 64;
 integer part = UInt(Q);
 integer elements = datasize DIV esize;
 
 CheckFPAdvSIMDEnabled64();
 bits(2*datasize) operand = V[n];
 bits(datasize) result;
 
 for e = 0 to elements-1
     Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);
 
 Vpart[d, part] = result;
 

.SS Assembler Symbols

 2
  Encoded in Q
  Is the second and upper half specifier. If present it causes the operation to
  be performed on the upper 64 bits of the registers holding the narrower
  elements, and is

  Q 2         
  0 [absent]  
  1 [present] 

 <Vd>
  Encoded in Rd
  Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

 <Tb>
  Encoded in sz:Q
  Is an arrangement specifier,

  sz Q <Tb> 
  0  0 4H   
  0  1 8H   
  1  0 2S   
  1  1 4S   

 <Vn>
  Encoded in Rn
  Is the name of the SIMD&FP source register, encoded in the "Rn" field.

 <Ta>
  Encoded in sz
  Is an arrangement specifier,

  sz <Ta> 
  0  4S   
  1  2D   



.SS Operation

 CheckFPAdvSIMDEnabled64();
 bits(2*datasize) operand = V[n];
 bits(datasize) result;
 
 for e = 0 to elements-1
     Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);
 
 Vpart[d, part] = result;

