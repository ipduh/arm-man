.nh
.TH "UCVTF (scalar, integer) -- A64" "7" " "  "instruction" "float"
.SS UCVTF (scalar, integer)
 Unsigned integer Convert to Floating-point (scalar)

 Unsigned integer Convert to Floating-point (scalar). This instruction converts
 the unsigned integer value in the general-purpose source register to a
 floating-point value using the rounding mode that is specified by the FPCR, and
 writes the result to the SIMD&FP destination register.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the current Security state and Exception level, an attempt to execute the
 instruction might be trapped.



.SS Floating-point - A64 - float
 
                                                                   
       29                                                          
     30 |              21                                          
   31 | |        24  22 |  19    16          10         5         0
    | | |         |   | |   |     |           |         |         |
  |.|0|0|1 1 1 1 0|. .|1|0 0|0 1 1|0 0 0 0 0 0|. . . . .|. . . . .|
  |   |           |     |   |                 |         |
  |   `-S         |     |   `-opcode          `-Rn      `-Rd
  `-sf            |     `-rmode
                  `-ftype
  
  
 
.SS 32-bit to half-precision(sf == 0 && ftype == 11)
 
 UCVTF  <Hd>, <Wn>
.SS 32-bit to single-precision(sf == 0 && ftype == 00)
 
 UCVTF  <Sd>, <Wn>
.SS 32-bit to double-precision(sf == 0 && ftype == 01)
 
 UCVTF  <Dd>, <Wn>
.SS 64-bit to half-precision(sf == 1 && ftype == 11)
 
 UCVTF  <Hd>, <Xn>
.SS 64-bit to single-precision(sf == 1 && ftype == 00)
 
 UCVTF  <Sd>, <Xn>
.SS 64-bit to double-precision(sf == 1 && ftype == 01)
 
 UCVTF  <Dd>, <Xn>
 
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 
 integer intsize = if sf == '1' then 64 else 32;
 integer fltsize;
 FPConvOp op;
 FPRounding rounding;
 boolean unsigned;
 integer part;
 
 case ftype of
     when '00'
         fltsize = 32;
     when '01'
         fltsize = 64;
     when '10'
         if opcode<2:1>:rmode != '11 01' then UNDEFINED;
         fltsize = 128;
     when '11'
         if HaveFP16Ext() then
             fltsize = 16;
         else
             UNDEFINED;
 
 case opcode<2:1>:rmode of
     when '00 xx'        // FCVT[NPMZ][US]
         rounding = FPDecodeRounding(rmode);
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_FtoI;
     when '01 00'        // [US]CVTF
         rounding = FPRoundingMode(FPCR);
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_ItoF;
     when '10 00'        // FCVTA[US]
         rounding = FPRounding_TIEAWAY;
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_FtoI;
     when '11 00'        // FMOV
         if fltsize != 16 && fltsize != intsize then UNDEFINED;
         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
         part = 0;
     when '11 01'        // FMOV D[1]
         if intsize != 64 || fltsize != 128 then UNDEFINED;
         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
         part = 1;
         fltsize = 64;  // size of D[1] is 64
     when '11 11'       // FJCVTZS
         if !HaveFJCVTZSExt() then UNDEFINED;
         rounding = FPRounding_ZERO;
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_FtoI_JS;
     otherwise 
         UNDEFINED;
 
 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
         V[d] = fltval;
     when FPConvOp_MOV_FtoI
         fltval = Vpart[n,part];
         intval = ZeroExtend(fltval, intsize);
         X[d] = intval;
     when FPConvOp_MOV_ItoF
         intval = X[n];
         fltval = intval<fltsize-1:0>;
         Vpart[d,part] = fltval;
     when FPConvOp_CVT_FtoI_JS
         bit Z;
         fltval = V[n];
         (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);
         PSTATE.<N,Z,C,V> = '0':Z:'00';
         X[d] = intval;
 

.SS Assembler Symbols

 <Dd>
  Encoded in Rd
  Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Hd>
  Encoded in Rd
  Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Sd>
  Encoded in Rd
  Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Xn>
  Encoded in Rn
  Is the 64-bit name of the general-purpose source register, encoded in the "Rn"
  field.

 <Wn>
  Encoded in Rn
  Is the 32-bit name of the general-purpose source register, encoded in the "Rn"
  field.



.SS Operation

 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
         V[d] = fltval;
     when FPConvOp_MOV_FtoI
         fltval = Vpart[n,part];
         intval = ZeroExtend(fltval, intsize);
         X[d] = intval;
     when FPConvOp_MOV_ItoF
         intval = X[n];
         fltval = intval<fltsize-1:0>;
         Vpart[d,part] = fltval;
     when FPConvOp_CVT_FtoI_JS
         bit Z;
         fltval = V[n];
         (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);
         PSTATE.<N,Z,C,V> = '0':Z:'00';
         X[d] = intval;

