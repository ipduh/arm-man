.nh
.TH "FMLAL, FMLAL2 (by element) -- A64" "7" " "  "instruction" "advsimd"
.SS FMLAL, FMLAL2 (by element)
 Floating-point fused Multiply-Add Long to accumulator (by element)

 Floating-point fused Multiply-Add Long to accumulator (by element). This
 instruction multiplies the vector elements in the first source SIMD&FP register
 by the specified value in the second source SIMD&FP register, and accumulates
 the product to the corresponding vector element of the destination SIMD&FP
 register. The instruction does not round the result of the multiply before the
 accumulation.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the current Security state and Exception level, an attempt to execute the
 instruction might be trapped.

 In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
 mandatory for all implementations to support it.


It has encodings from 2 classes: FMLAL and FMLAL2

.SS FMLAL - A64 - FMLAL_asimdelem_LH
 
                       21                                          
       29            22 |            14      10                    
     30 |          23 | |          15 |    11 |                    
   31 | |        24 | | |20      16 | |  12 | |         5         0
    | | |         | | | | |       | | |   | | |         |         |
   0|.|0|0 1 1 1 1|1|0|.|.|. . . .|0|0|0 0|.|0|. . . . .|. . . . .|
    | |           | | | | |       | | |   |   |         |
    | `-U         | | | | `-Rm    | | |   `-H `-Rn      `-Rd
    `-Q           | | | `-M       | | `-opcode[1:0]
                  | | `-L         | `-S
                  | `-sz          `-opcode[3]
                  `-size[1]
  
  
 
.SS FMLAL
 
 FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
 
 if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
 if sz == '1' then UNDEFINED;
 integer index = UInt(H:L:M); 
 
 integer esize = 32;
 integer datasize = if Q=='1' then 128 else 64;
 integer elements = datasize DIV esize;
 
 boolean sub_op = (S == '1');
 integer part = 0;
.SS FMLAL2 - A64 - FMLAL2_asimdelem_LH
 
                       21                                          
       29            22 |            14      10                    
     30 |          23 | |          15 |    11 |                    
   31 | |        24 | | |20      16 | |  12 | |         5         0
    | | |         | | | | |       | | |   | | |         |         |
   0|.|1|0 1 1 1 1|1|0|.|.|. . . .|1|0|0 0|.|0|. . . . .|. . . . .|
    | |           | | | | |       | | |   |   |         |
    | `-U         | | | | `-Rm    | | |   `-H `-Rn      `-Rd
    `-Q           | | | `-M       | | `-opcode[1:0]
                  | | `-L         | `-S
                  | `-sz          `-opcode[3]
                  `-size[1]
  
  
 
.SS FMLAL2
 
 FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]
 
 if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
 if sz == '1' then UNDEFINED;
 integer index = UInt(H:L:M); 
 
 integer esize = 32;
 integer datasize = if Q=='1' then 128 else 64;
 integer elements = datasize DIV esize;
 
 boolean sub_op = (S == '1');
 integer part = 1;
 
 CheckFPAdvSIMDEnabled64();
 bits(datasize DIV 2) operand1 = Vpart[n,part];
 bits(128) operand2 = V[m];
 bits(datasize) operand3 = V[d];
 bits(datasize) result;
 bits(esize DIV 2) element1;
 bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
 
 for e = 0 to elements-1
     element1 = Elem[operand1, e, esize DIV 2];
     if sub_op then element1 = FPNeg(element1);
     Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
 V[d] = result;
 

.SS Assembler Symbols

 <Vd>
  Encoded in Rd
  Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

 <Ta>
  Encoded in Q
  Is an arrangement specifier,

  Q <Ta> 
  0 2S   
  1 4S   

 <Vn>
  Encoded in Rn
  Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

 <Tb>
  Encoded in Q
  Is an arrangement specifier,

  Q <Tb> 
  0 2H   
  1 4H   

 <Vm>
  Encoded in Rm
  Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

 <index>
  Encoded in H:L:M
  Is the element index, encoded in the "H:L:M" fields.



.SS Operation

 CheckFPAdvSIMDEnabled64();
 bits(datasize DIV 2) operand1 = Vpart[n,part];
 bits(128) operand2 = V[m];
 bits(datasize) operand3 = V[d];
 bits(datasize) result;
 bits(esize DIV 2) element1;
 bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
 
 for e = 0 to elements-1
     element1 = Elem[operand1, e, esize DIV 2];
     if sub_op then element1 = FPNeg(element1);
     Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
 V[d] = result;

