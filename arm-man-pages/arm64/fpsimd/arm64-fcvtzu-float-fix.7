.nh
.TH "FCVTZU (scalar, fixed-point) -- A64" "7" " "  "instruction" "float"
.SS FCVTZU (scalar, fixed-point)
 Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)

 Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar).
 This instruction converts the floating-point value in the SIMD&FP source
 register to a 32-bit or 64-bit fixed-point unsigned integer using the Round
 towards Zero rounding mode, and writes the result to the general-purpose
 destination register.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the Security state and Exception level in which the instruction is
 executed, an attempt to execute the instruction might be trapped.



.SS Floating-point - A64 - float
 
                                                                   
       29                                                          
     30 |              21                                          
   31 | |        24  22 |  19    16          10         5         0
    | | |         |   | |   |     |           |         |         |
  |.|0|0|1 1 1 1 0|. .|0|1 1|0 0 1|. . . . . .|. . . . .|. . . . .|
  |   |           |     |   |     |           |         |
  |   `-S         |     |   |     `-scale     `-Rn      `-Rd
  `-sf            |     |   `-opcode
                  |     `-rmode
                  `-ftype
  
  
 
.SS Half-precision to 32-bit(sf == 0 && ftype == 11)
 
 FCVTZU  <Wd>, <Hn>, #<fbits>
.SS Half-precision to 64-bit(sf == 1 && ftype == 11)
 
 FCVTZU  <Xd>, <Hn>, #<fbits>
.SS Single-precision to 32-bit(sf == 0 && ftype == 00)
 
 FCVTZU  <Wd>, <Sn>, #<fbits>
.SS Single-precision to 64-bit(sf == 1 && ftype == 00)
 
 FCVTZU  <Xd>, <Sn>, #<fbits>
.SS Double-precision to 32-bit(sf == 0 && ftype == 01)
 
 FCVTZU  <Wd>, <Dn>, #<fbits>
.SS Double-precision to 64-bit(sf == 1 && ftype == 01)
 
 FCVTZU  <Xd>, <Dn>, #<fbits>
 
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 
 integer intsize = if sf == '1' then 64 else 32;
 integer fltsize;
 FPConvOp op;
 FPRounding rounding;
 boolean unsigned;
 
 case ftype of
     when '00' fltsize = 32;
     when '01' fltsize = 64;
     when '10' UNDEFINED;
     when '11'
         if HaveFP16Ext() then
             fltsize = 16;
         else
             UNDEFINED;
 
 if sf == '0' && scale<5> == '0' then UNDEFINED;
 integer fracbits = 64 - UInt(scale);
 
 case opcode<2:1>:rmode of
     when '00 11'        // FCVTZ
         rounding = FPRounding_ZERO;
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_FtoI;
     when '01 00'        // [US]CVTF
         rounding = FPRoundingMode(FPCR);
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_ItoF;
     otherwise
         UNDEFINED;
 
 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
         V[d] = fltval;
 

.SS Assembler Symbols

 <Wd>
  Encoded in Rd
  Is the 32-bit name of the general-purpose destination register, encoded in the
  "Rd" field.

 <Xd>
  Encoded in Rd
  Is the 64-bit name of the general-purpose destination register, encoded in the
  "Rd" field.

 <Sn>
  Encoded in Rn
  Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

 <Hn>
  Encoded in Rn
  Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

 <Dn>
  Encoded in Rn
  Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

 <fbits>
  Encoded in scale
  For the double-precision to 32-bit, half-precision to 32-bit and single-
  precision to 32-bit variant: is the number of bits after the binary point in
  the fixed-point destination, in the range 1 to 32, encoded as 64 minus
  "scale".

 <fbits>
  Encoded in scale
  For the double-precision to 64-bit, half-precision to 64-bit and single-
  precision to 64-bit variant: is the number of bits after the binary point in
  the fixed-point destination, in the range 1 to 64, encoded as 64 minus
  "scale".



.SS Operation

 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
         V[d] = fltval;

