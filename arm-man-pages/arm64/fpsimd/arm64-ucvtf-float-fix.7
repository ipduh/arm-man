.nh
.TH "UCVTF (scalar, fixed-point) -- A64" "7" " "  "instruction" "float"
.SS UCVTF (scalar, fixed-point)
 Unsigned fixed-point Convert to Floating-point (scalar)

 Unsigned fixed-point Convert to Floating-point (scalar). This instruction
 converts the unsigned value in the 32-bit or 64-bit general-purpose source
 register to a floating-point value using the rounding mode that is specified by
 the FPCR, and writes the result to the SIMD&FP destination register.

 A floating-point exception can be generated by this instruction. Depending on
 the settings in FPCR, the exception results in either a flag being set in FPSR,
 or a synchronous exception being generated. For more information, see Floating-
 point exception traps.

 Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
 and the Security state and Exception level in which the instruction is
 executed, an attempt to execute the instruction might be trapped.



.SS Floating-point - A64 - float
 
                                                                   
       29                                                          
     30 |              21                                          
   31 | |        24  22 |  19    16          10         5         0
    | | |         |   | |   |     |           |         |         |
  |.|0|0|1 1 1 1 0|. .|0|0 0|0 1 1|. . . . . .|. . . . .|. . . . .|
  |   |           |     |   |     |           |         |
  |   `-S         |     |   |     `-scale     `-Rn      `-Rd
  `-sf            |     |   `-opcode
                  |     `-rmode
                  `-ftype
  
  
 
.SS 32-bit to half-precision(sf == 0 && ftype == 11)
 
 UCVTF  <Hd>, <Wn>, #<fbits>
.SS 32-bit to single-precision(sf == 0 && ftype == 00)
 
 UCVTF  <Sd>, <Wn>, #<fbits>
.SS 32-bit to double-precision(sf == 0 && ftype == 01)
 
 UCVTF  <Dd>, <Wn>, #<fbits>
.SS 64-bit to half-precision(sf == 1 && ftype == 11)
 
 UCVTF  <Hd>, <Xn>, #<fbits>
.SS 64-bit to single-precision(sf == 1 && ftype == 00)
 
 UCVTF  <Sd>, <Xn>, #<fbits>
.SS 64-bit to double-precision(sf == 1 && ftype == 01)
 
 UCVTF  <Dd>, <Xn>, #<fbits>
 
 integer d = UInt(Rd);
 integer n = UInt(Rn);
 
 integer intsize = if sf == '1' then 64 else 32;
 integer fltsize;
 FPConvOp op;
 FPRounding rounding;
 boolean unsigned;
 
 case ftype of
     when '00' fltsize = 32;
     when '01' fltsize = 64;
     when '10' UNDEFINED;
     when '11'
         if HaveFP16Ext() then
             fltsize = 16;
         else
             UNDEFINED;
 
 if sf == '0' && scale<5> == '0' then UNDEFINED;
 integer fracbits = 64 - UInt(scale);
 
 case opcode<2:1>:rmode of
     when '00 11'        // FCVTZ
         rounding = FPRounding_ZERO;
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_FtoI;
     when '01 00'        // [US]CVTF
         rounding = FPRoundingMode(FPCR);
         unsigned = (opcode<0> == '1');
         op = FPConvOp_CVT_ItoF;
     otherwise
         UNDEFINED;
 
 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
         V[d] = fltval;
 

.SS Assembler Symbols

 <Dd>
  Encoded in Rd
  Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Hd>
  Encoded in Rd
  Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Sd>
  Encoded in Rd
  Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd"
  field.

 <Xn>
  Encoded in Rn
  Is the 64-bit name of the general-purpose source register, encoded in the "Rn"
  field.

 <Wn>
  Encoded in Rn
  Is the 32-bit name of the general-purpose source register, encoded in the "Rn"
  field.

 <fbits>
  Encoded in scale
  For the 32-bit to double-precision, 32-bit to half-precision and 32-bit to
  single-precision variant: is the number of bits after the binary point in the
  fixed-point source, in the range 1 to 32, encoded as 64 minus "scale".

 <fbits>
  Encoded in scale
  For the 64-bit to double-precision, 64-bit to half-precision and 64-bit to
  single-precision variant: is the number of bits after the binary point in the
  fixed-point source, in the range 1 to 64, encoded as 64 minus "scale".



.SS Operation

 CheckFPAdvSIMDEnabled64();
 
 bits(fltsize) fltval;
 bits(intsize) intval;
 
 case op of
     when FPConvOp_CVT_FtoI
         fltval = V[n];
         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
         X[d] = intval;
     when FPConvOp_CVT_ItoF
         intval = X[n];
         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
         V[d] = fltval;

